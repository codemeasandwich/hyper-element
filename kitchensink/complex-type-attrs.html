<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Complex Type Attributes - hyper-element Kitchen Sink</title>
  <script src="https://cdn.jsdelivr.net/npm/hyperhtml@latest/min.js"></script>
  <script src="test-loader.js"></script>
  <style>
    body { font-family: sans-serif; padding: 2rem; }
    section { margin: 2rem 0; padding: 1rem; border: 1px solid #ddd; border-radius: 4px; }
    section[data-test-result="pass"] { border-color: green; background: #f0fff0; }
    section[data-test-result="fail"] { border-color: red; background: #fff0f0; }
    h1 { border-bottom: 2px solid #333; }
    h2 { margin-top: 0; }
    pre { background: #f5f5f5; padding: 1rem; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>Complex Type Attributes</h1>
  <p>Tests passing objects and functions to custom child elements.</p>

  <!-- Issue #9: Bug passing complex type without function -->
  <section data-test="object-only-attr" data-test-result="pending">
    <h2>Issue #9: Object Attribute Without Function</h2>
    <p>Passing only an object (no function) to a custom element should work.</p>
    <pre><code>// Should work but currently fails:
Html\`&lt;child-elem data=${{a:2}} name="test"/&gt;\`

// Currently only works when a function is also passed:
Html\`&lt;child-elem fn=${this.fn} data=${{a:2}} name="test"/&gt;\`</code></pre>
    <parent-obj-elem></parent-obj-elem>
    <script>
      customElements.define("child-obj-elem", class extends hyperElement {
        render(Html) {
          const config = this.attrs.config;
          const isObject = config && typeof config === 'object';
          const hasProperty = isObject && config.a === 2;
          Html`<span id="obj-result">${hasProperty ? 'PASS' : 'FAIL: ' + JSON.stringify(config)}</span>`
        }
      });

      customElements.define("parent-obj-elem", class extends hyperElement {
        render(Html) {
          // Pass ONLY an object, no function
          Html`<child-obj-elem config=${{a:2}} name="test"></child-obj-elem>`
        }
      });

      requestAnimationFrame(() => {
        setTimeout(() => {
          const section = document.querySelector('[data-test="object-only-attr"]');
          const result = document.querySelector('#obj-result');
          if (result && result.textContent === 'PASS') {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        }, 100);
      });
    </script>
  </section>

  <!-- Issue #10: Bug passing complex type with preceding element -->
  <section data-test="complex-with-preceding" data-test-result="pending">
    <h2>Issue #10: Complex Types After Preceding Element</h2>
    <p>Complex types should work even when another element precedes in the template.</p>
    <pre><code>// Should work but currently fails:
Html\`&lt;span&gt;text&lt;/span&gt;&lt;child-elem fn=${this.fn} data=${{a:2}}/&gt;\`</code></pre>
    <parent-preceding-elem></parent-preceding-elem>
    <script>
      customElements.define("child-preceding-elem", class extends hyperElement {
        render(Html) {
          const fn = this.attrs.callback;
          const config = this.attrs.config;
          const fnWorks = typeof fn === 'function' && fn() === 'OK';
          const configWorks = config && typeof config === 'object' && config.value === 42;
          Html`<span id="preceding-result">${fnWorks && configWorks ? 'PASS' : 'FAIL fn:' + typeof fn + ' config:' + JSON.stringify(config)}</span>`
        }
      });

      customElements.define("parent-preceding-elem", class extends hyperElement {
        getValue() { return 'OK'; }
        render(Html) {
          // Element before the custom element with complex attrs
          Html`<span>Before</span><child-preceding-elem callback=${this.getValue} config=${{value:42}}></child-preceding-elem>`
        }
      });

      requestAnimationFrame(() => {
        setTimeout(() => {
          const section = document.querySelector('[data-test="complex-with-preceding"]');
          const result = document.querySelector('#preceding-result');
          if (result && result.textContent === 'PASS') {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        }, 100);
      });
    </script>
  </section>

  <!-- Combined test: object only + preceding -->
  <section data-test="object-only-with-preceding" data-test-result="pending">
    <h2>Combined: Object Only + Preceding Element</h2>
    <p>Passing only an object after a preceding element should work.</p>
    <parent-combo-elem></parent-combo-elem>
    <script>
      customElements.define("child-combo-elem", class extends hyperElement {
        render(Html) {
          const data = this.attrs.config;
          const isObject = data && typeof data === 'object';
          const hasProperties = isObject && data.x === 1 && data.y === 2;
          Html`<span id="combo-result">${hasProperties ? 'PASS' : 'FAIL: ' + JSON.stringify(data)}</span>`
        }
      });

      customElements.define("parent-combo-elem", class extends hyperElement {
        render(Html) {
          Html`<div>Header</div><child-combo-elem config=${{x:1, y:2}}></child-combo-elem>`
        }
      });

      requestAnimationFrame(() => {
        setTimeout(() => {
          const section = document.querySelector('[data-test="object-only-with-preceding"]');
          const result = document.querySelector('#combo-result');
          if (result && result.textContent === 'PASS') {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        }, 100);
      });
    </script>
  </section>

  <a href="index.html">&larr; Back to Kitchen Sink</a>
</body>
</html>
