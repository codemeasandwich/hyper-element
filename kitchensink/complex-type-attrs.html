<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Complex Type Attributes - hyper-element Kitchen Sink</title>
    <script src="test-loader.js"></script>
    <style>
      body {
        font-family: sans-serif;
        padding: 2rem;
      }
      section {
        margin: 2rem 0;
        padding: 1rem;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      section[data-test-result='pass'] {
        border-color: green;
        background: #f0fff0;
      }
      section[data-test-result='fail'] {
        border-color: red;
        background: #fff0f0;
      }
      h1 {
        border-bottom: 2px solid #333;
      }
      h2 {
        margin-top: 0;
      }
      pre {
        background: #f5f5f5;
        padding: 1rem;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <h1>Complex Type Attributes</h1>
    <p>
      Tests passing objects, functions, and booleans to custom child elements.
    </p>

    <!-- Issue #9: Bug passing complex type without function -->
    <section data-test="object-only-attr" data-test-result="pending">
      <h2>Issue #9: Object Attribute Without Function</h2>
      <p>
        Passing only an object (no function) to a custom element should work.
      </p>
      <pre><code>// Should work but currently fails:
Html\`&lt;child-elem data=${{a:2}} name="test"/&gt;\`

// Currently only works when a function is also passed:
Html\`&lt;child-elem fn=${this.fn} data=${{a:2}} name="test"/&gt;\`</code></pre>
      <parent-obj-elem></parent-obj-elem>
      <script>
        customElements.define(
          'child-obj-elem',
          class extends hyperElement {
            render(Html) {
              const config = this.attrs.config;
              const isObject = config && typeof config === 'object';
              const hasProperty = isObject && config.a === 2;
              Html`<span id="obj-result">${hasProperty ? 'PASS' : 'FAIL: ' + JSON.stringify(config)}</span>`;
            }
          }
        );

        customElements.define(
          'parent-obj-elem',
          class extends hyperElement {
            render(Html) {
              // Pass ONLY an object, no function
              Html`<child-obj-elem config=${{ a: 2 }} name="test"></child-obj-elem>`;
            }
          }
        );

        requestAnimationFrame(() => {
          setTimeout(() => {
            const section = document.querySelector(
              '[data-test="object-only-attr"]'
            );
            const result = document.querySelector('#obj-result');
            if (result && result.textContent === 'PASS') {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 100);
        });
      </script>
    </section>

    <!-- Issue #10: Bug passing complex type with preceding element -->
    <section data-test="complex-with-preceding" data-test-result="pending">
      <h2>Issue #10: Complex Types After Preceding Element</h2>
      <p>
        Complex types should work even when another element precedes in the
        template.
      </p>
      <pre><code>// Should work but currently fails:
Html\`&lt;span&gt;text&lt;/span&gt;&lt;child-elem fn=${this.fn} data=${{a:2}}/&gt;\`</code></pre>
      <parent-preceding-elem></parent-preceding-elem>
      <script>
        customElements.define(
          'child-preceding-elem',
          class extends hyperElement {
            render(Html) {
              const fn = this.attrs.callback;
              const config = this.attrs.config;
              const fnWorks = typeof fn === 'function' && fn() === 'OK';
              const configWorks =
                config && typeof config === 'object' && config.value === 42;
              Html`<span id="preceding-result">${fnWorks && configWorks ? 'PASS' : 'FAIL fn:' + typeof fn + ' config:' + JSON.stringify(config)}</span>`;
            }
          }
        );

        customElements.define(
          'parent-preceding-elem',
          class extends hyperElement {
            getValue() {
              return 'OK';
            }
            render(Html) {
              // Element before the custom element with complex attrs
              Html`<span>Before</span><child-preceding-elem callback=${this.getValue} config=${{ value: 42 }}></child-preceding-elem>`;
            }
          }
        );

        requestAnimationFrame(() => {
          setTimeout(() => {
            const section = document.querySelector(
              '[data-test="complex-with-preceding"]'
            );
            const result = document.querySelector('#preceding-result');
            if (result && result.textContent === 'PASS') {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 100);
        });
      </script>
    </section>

    <!-- Combined test: object only + preceding -->
    <section data-test="object-only-with-preceding" data-test-result="pending">
      <h2>Combined: Object Only + Preceding Element</h2>
      <p>Passing only an object after a preceding element should work.</p>
      <parent-combo-elem></parent-combo-elem>
      <script>
        customElements.define(
          'child-combo-elem',
          class extends hyperElement {
            render(Html) {
              const data = this.attrs.config;
              const isObject = data && typeof data === 'object';
              const hasProperties = isObject && data.x === 1 && data.y === 2;
              Html`<span id="combo-result">${hasProperties ? 'PASS' : 'FAIL: ' + JSON.stringify(data)}</span>`;
            }
          }
        );

        customElements.define(
          'parent-combo-elem',
          class extends hyperElement {
            render(Html) {
              Html`<div>Header</div><child-combo-elem config=${{ x: 1, y: 2 }}></child-combo-elem>`;
            }
          }
        );

        requestAnimationFrame(() => {
          setTimeout(() => {
            const section = document.querySelector(
              '[data-test="object-only-with-preceding"]'
            );
            const result = document.querySelector('#combo-result');
            if (result && result.textContent === 'PASS') {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 100);
        });
      </script>
    </section>

    <!-- Boolean attribute passing -->
    <section data-test="boolean-attr" data-test-result="pending">
      <h2>Boolean Attribute Passing</h2>
      <p>Boolean values passed to custom elements should remain as booleans.</p>
      <pre><code>Html\`&lt;child-elem enabled=${true} disabled=${false}/&gt;\`
// Child receives: this.attrs.enabled === true (boolean)
// Child receives: this.attrs.disabled === false (boolean)</code></pre>
      <parent-bool-elem></parent-bool-elem>
      <script>
        customElements.define(
          'child-bool-elem',
          class extends hyperElement {
            render(Html) {
              const enabled = this.attrs.enabled;
              const disabled = this.attrs.disabled;
              const enabledIsBool = enabled === true;
              const disabledIsBool = disabled === false;
              const pass = enabledIsBool && disabledIsBool;
              Html`<span id="bool-result">${pass ? 'PASS' : 'FAIL: enabled=' + JSON.stringify(enabled) + '(' + typeof enabled + ') disabled=' + JSON.stringify(disabled) + '(' + typeof disabled + ')'}</span>`;
            }
          }
        );

        customElements.define(
          'parent-bool-elem',
          class extends hyperElement {
            render(Html) {
              Html`<child-bool-elem enabled=${true} disabled=${false}></child-bool-elem>`;
            }
          }
        );

        requestAnimationFrame(() => {
          setTimeout(() => {
            const section = document.querySelector(
              '[data-test="boolean-attr"]'
            );
            const result = document.querySelector('#bool-result');
            if (result && result.textContent === 'PASS') {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 100);
        });
      </script>
    </section>

    <!-- Number attribute passing -->
    <section data-test="number-attr" data-test-result="pending">
      <h2>Number Attribute Passing</h2>
      <p>Number values passed to custom elements should remain as numbers.</p>
      <pre><code>Html\`&lt;child-elem count=${42} pi=${3.14}/&gt;\`
// Child receives: this.attrs.count === 42 (number)
// Child receives: this.attrs.pi === 3.14 (number)</code></pre>
      <parent-num-elem></parent-num-elem>
      <script>
        customElements.define(
          'child-num-elem',
          class extends hyperElement {
            render(Html) {
              const count = this.attrs.count;
              const pi = this.attrs.pi;
              const countIsNum = count === 42 && typeof count === 'number';
              const piIsNum = pi === 3.14 && typeof pi === 'number';
              const pass = countIsNum && piIsNum;
              Html`<span id="num-result">${pass ? 'PASS' : 'FAIL: count=' + count + '(' + typeof count + ') pi=' + pi + '(' + typeof pi + ')'}</span>`;
            }
          }
        );

        customElements.define(
          'parent-num-elem',
          class extends hyperElement {
            render(Html) {
              Html`<child-num-elem count=${42} pi=${3.14}></child-num-elem>`;
            }
          }
        );

        requestAnimationFrame(() => {
          setTimeout(() => {
            const section = document.querySelector('[data-test="number-attr"]');
            const result = document.querySelector('#num-result');
            if (result && result.textContent === 'PASS') {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 100);
        });
      </script>
    </section>

    <!-- Multiline template with newline after tag name -->
    <section data-test="multiline-attr" data-test-result="pending">
      <h2>Multiline Template: Newline After Tag Name</h2>
      <p>Boolean values should work when tag name is followed by newline.</p>
      <pre><code>// Tag name followed by newline (not space):
Html\`&lt;child-elem
  expanded=${true}
  config=${{ a: 1 }}
&gt;\`</code></pre>
      <parent-multiline-elem></parent-multiline-elem>
      <script>
        customElements.define(
          'child-multiline-elem',
          class extends hyperElement {
            render(Html) {
              const expanded = this.attrs.expanded;
              const config = this.attrs.config;
              const expandedIsBool = expanded === true;
              const configIsObj =
                config && typeof config === 'object' && config.a === 1;
              const pass = expandedIsBool && configIsObj;
              Html`<span id="multiline-result">${pass ? 'PASS' : 'FAIL: expanded=' + JSON.stringify(expanded) + '(' + typeof expanded + ') config=' + JSON.stringify(config)}</span>`;
            }
          }
        );

        customElements.define(
          'parent-multiline-elem',
          class extends hyperElement {
            render(Html) {
              // Critical: tag name followed by NEWLINE, not space
              Html`<child-multiline-elem
                expanded=${true}
                config=${{ a: 1 }}
              ></child-multiline-elem>`;
            }
          }
        );

        requestAnimationFrame(() => {
          setTimeout(() => {
            const section = document.querySelector(
              '[data-test="multiline-attr"]'
            );
            const result = document.querySelector('#multiline-result');
            if (result && result.textContent === 'PASS') {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 100);
        });
      </script>
    </section>

    <a href="index.html">&larr; Back to Kitchen Sink</a>
  </body>
</html>
