<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Coverage Edge Cases - hyper-element Kitchen Sink</title>
    <script src="https://cdn.jsdelivr.net/npm/hyperhtml@latest/min.js"></script>
    <script src="test-loader.js"></script>
    <style>
      body {
        font-family: sans-serif;
        padding: 2rem;
      }
      section {
        margin: 2rem 0;
        padding: 1rem;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      section[data-test-result='pass'] {
        border-color: green;
        background: #f0fff0;
      }
      section[data-test-result='fail'] {
        border-color: red;
        background: #fff0f0;
      }
      h1 {
        border-bottom: 2px solid #333;
      }
      h2 {
        margin-top: 0;
      }
      pre {
        background: #f5f5f5;
        padding: 1rem;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <h1>Coverage Edge Cases</h1>
    <p>Tests for edge cases to achieve 100% code coverage.</p>

    <!-- Test: Base render() method (no override) -->
    <section data-test="base-render" data-test-result="pending">
      <h2>Base render() Method (No Override)</h2>
      <p>
        Tests that a hyperElement without an overridden render() still works.
      </p>
      <div id="base-render-output"></div>
      <script>
        customElements.define(
          'base-render-elem',
          class extends hyperElement {
            // Intentionally no render() method - uses base class empty stub
          }
        );

        const baseRenderElem = document.createElement('base-render-elem');
        document
          .getElementById('base-render-output')
          .appendChild(baseRenderElem);

        requestAnimationFrame(() => {
          const section = document.querySelector('[data-test="base-render"]');
          // Element should exist and be connected, even with empty render
          if (baseRenderElem && baseRenderElem.isConnected) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        });
      </script>
    </section>

    <!-- Test: setup without store (undefined store path) -->
    <section data-test="setup-no-store" data-test-result="pending">
      <h2>Setup with No Store (undefined)</h2>
      <p>Tests the onNext function when called without a store argument.</p>
      <div id="no-store-output"></div>
      <script>
        customElements.define(
          'no-store-elem',
          class extends hyperElement {
            setup(attachStore) {
              // Call attachStore with no arguments - triggers undefined store path
              const trigger = attachStore();
              setTimeout(() => trigger(), 10);
            }
            render(Html) {
              Html`<span>No store render</span>`;
            }
          }
        );

        const elem = document.createElement('no-store-elem');
        document.getElementById('no-store-output').appendChild(elem);

        setTimeout(() => {
          const section = document.querySelector(
            '[data-test="setup-no-store"]'
          );
          if (elem && elem.textContent.includes('No store render')) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        }, 100);
      </script>
    </section>

    <!-- Test: innerShadow getter -->
    <section data-test="inner-shadow" data-test-result="pending">
      <h2>innerShadow Getter</h2>
      <p>Tests accessing the innerShadow property.</p>
      <div id="inner-shadow-output"></div>
      <script>
        customElements.define(
          'inner-shadow-elem',
          class extends hyperElement {
            render(Html) {
              Html`<span class="inner-content">Shadow content here</span>`;
            }
          }
        );

        const elem2 = document.createElement('inner-shadow-elem');
        document.getElementById('inner-shadow-output').appendChild(elem2);

        requestAnimationFrame(() => {
          const section = document.querySelector('[data-test="inner-shadow"]');
          // Access innerShadow getter
          const shadow = elem2.innerShadow;
          if (shadow && shadow.includes('Shadow content here')) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        });
      </script>
    </section>

    <!-- Test: disconnectedCallback / teardown -->
    <section data-test="disconnected" data-test-result="pending">
      <h2>Disconnected Callback (Teardown)</h2>
      <p>Tests that teardown function is called when element is removed.</p>
      <div id="disconnected-output"></div>
      <script>
        let teardownCalled = false;

        customElements.define(
          'teardown-elem',
          class extends hyperElement {
            setup(attachStore) {
              attachStore({ count: 0 });
              // Return teardown function
              return () => {
                teardownCalled = true;
              };
            }
            render(Html, store) {
              Html`<span>Count: ${store ? store.count : 0}</span>`;
            }
          }
        );

        const container = document.getElementById('disconnected-output');
        const elem6 = document.createElement('teardown-elem');
        container.appendChild(elem6);

        setTimeout(() => {
          // Remove element to trigger disconnectedCallback
          container.removeChild(elem6);

          setTimeout(() => {
            const section = document.querySelector(
              '[data-test="disconnected"]'
            );
            if (teardownCalled) {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 50);
        }, 50);
      </script>
    </section>

    <!-- Test: async fragment with array values -->
    <section data-test="async-fragment-array" data-test-result="pending">
      <h2>Async Fragment with Array Values</h2>
      <p>Tests async fragment template that returns an array of values.</p>
      <div id="async-array-output"></div>
      <script>
        customElements.define(
          'async-array-elem',
          class extends hyperElement {
            Items() {
              return {
                placeholder: 'Loading items...',
                template: Promise.resolve({
                  template: '<li>{name}</li>',
                  values: [
                    { name: 'Item A' },
                    { name: 'Item B' },
                    { name: 'Item C' },
                  ],
                }),
              };
            }
            render(Html) {
              Html`<ul>${{ Items: {} }}</ul>`;
            }
          }
        );

        const elem8 = document.createElement('async-array-elem');
        document.getElementById('async-array-output').appendChild(elem8);

        setTimeout(() => {
          const section = document.querySelector(
            '[data-test="async-fragment-array"]'
          );
          const content = elem8.textContent;
          if (
            content.includes('Item A') &&
            content.includes('Item B') &&
            content.includes('Item C')
          ) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        }, 300);
      </script>
    </section>

    <!-- Test: async fragment with string return and values from data -->
    <section data-test="async-fragment-string" data-test-result="pending">
      <h2>Async Fragment with String Return</h2>
      <p>
        Tests async fragment that returns just a string template (uses data
        param for values).
      </p>
      <div id="async-string-output"></div>
      <script>
        customElements.define(
          'async-string-elem',
          class extends hyperElement {
            Message(data) {
              // When promise resolves to just a string, the 'data' passed to fragment is used for values
              return {
                placeholder: 'Loading...',
                template: Promise.resolve({
                  template: '<p>Hello {name}!</p>',
                  values: data, // Use the data passed from render
                }),
              };
            }
            render(Html) {
              Html`${{ Message: { name: 'World' } }}`;
            }
          }
        );

        const elem9 = document.createElement('async-string-elem');
        document.getElementById('async-string-output').appendChild(elem9);

        setTimeout(() => {
          const section = document.querySelector(
            '[data-test="async-fragment-string"]'
          );
          if (elem9.textContent.includes('Hello World!')) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        }, 300);
      </script>
    </section>

    <!-- Test: async fragment promise resolves to plain string -->
    <section data-test="async-plain-string" data-test-result="pending">
      <h2>Async Fragment - Promise Resolves to Plain String</h2>
      <p>
        Tests async fragment where promise resolves directly to a template
        string (no variables).
      </p>
      <div id="async-plain-output"></div>
      <script>
        customElements.define(
          'async-plain-elem',
          class extends hyperElement {
            PlainMsg(data) {
              // Promise resolves to just a string - tests line 272-274
              // When returning just a string, values defaults to {} so no substitution happens
              return {
                placeholder: 'Loading...',
                template: Promise.resolve('<p>Static message loaded</p>'),
              };
            }
            render(Html) {
              Html`${{ PlainMsg: {} }}`;
            }
          }
        );

        const elemPlain = document.createElement('async-plain-elem');
        document.getElementById('async-plain-output').appendChild(elemPlain);

        setTimeout(() => {
          const section = document.querySelector(
            '[data-test="async-plain-string"]'
          );
          // When promise returns just string, no variable substitution (values = {})
          if (elemPlain.textContent.includes('Static message loaded')) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        }, 300);
      </script>
    </section>

    <!-- Test: fragment with once:true caching -->
    <section data-test="fragment-once" data-test-result="pending">
      <h2>Fragment with once:true Caching</h2>
      <p>Tests that fragments with once:true only execute once.</p>
      <div id="fragment-once-output"></div>
      <script>
        let fragmentCallCount = 0;

        customElements.define(
          'once-frag-elem',
          class extends hyperElement {
            Cached(data) {
              fragmentCallCount++;
              return {
                once: true,
                any: 'Cached content (calls: ' + fragmentCallCount + ')',
              };
            }
            setup(attachStore) {
              const trigger = attachStore();
              // Trigger multiple re-renders
              setTimeout(() => trigger(), 20);
              setTimeout(() => trigger(), 40);
            }
            render(Html) {
              Html`<span>${{ Cached: {} }}</span>`;
            }
          }
        );

        const elem10 = document.createElement('once-frag-elem');
        document.getElementById('fragment-once-output').appendChild(elem10);

        setTimeout(() => {
          const section = document.querySelector('[data-test="fragment-once"]');
          // Fragment should only have been called once despite multiple renders
          if (
            fragmentCallCount === 1 &&
            elem10.textContent.includes('calls: 1')
          ) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        }, 150);
      </script>
    </section>

    <!-- Test: 'on' attribute error -->
    <section data-test="on-attr-error" data-test-result="pending">
      <h2>'on' Attribute Error</h2>
      <p>Tests that using 'on*' attributes with functions throws an error.</p>
      <div id="on-attr-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="on-attr-error"]');
          let errorThrown = false;

          customElements.define(
            'on-error-parent',
            class extends hyperElement {
              handleClick() {
                console.log('clicked');
              }
              render(Html) {
                try {
                  // Attempting to pass a function via onclick should throw
                  Html`<on-error-child onclick=${this.handleClick}></on-error-child>`;
                } catch (e) {
                  if (e.message.includes("'on' is reserve")) {
                    errorThrown = true;
                  }
                }
              }
            }
          );

          customElements.define(
            'on-error-child',
            class extends hyperElement {
              render(Html) {
                Html`<span>Child</span>`;
              }
            }
          );

          const elem = document.createElement('on-error-parent');
          document.getElementById('on-attr-output').appendChild(elem);

          setTimeout(() => {
            if (errorThrown) {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: unknown template type error -->
    <section data-test="unknown-template-error" data-test-result="pending">
      <h2>Unknown Template Type Error</h2>
      <p>Tests that invalid template type throws an error.</p>
      <div id="unknown-template-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="unknown-template-error"]'
          );
          let errorThrown = false;

          customElements.define(
            'bad-template-elem',
            class extends hyperElement {
              BadFragment(data) {
                return {
                  // Invalid template type (number instead of string or promise)
                  template: 12345,
                };
              }
              render(Html) {
                try {
                  Html`${{ BadFragment: {} }}`;
                } catch (e) {
                  if (e.message.includes('unknow template type')) {
                    errorThrown = true;
                  }
                }
              }
            }
          );

          const elem = document.createElement('bad-template-elem');
          document.getElementById('unknown-template-output').appendChild(elem);

          setTimeout(() => {
            if (errorThrown) {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: attributeChangedCallback - dynamic attribute change triggers re-render -->
    <section data-test="attr-change-rerender" data-test-result="pending">
      <h2>Attribute Change Triggers Re-render</h2>
      <p>
        Tests that changing an attribute after element is connected triggers
        re-render.
      </p>
      <div id="attr-change-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="attr-change-rerender"]'
          );
          let renderCount = 0;

          customElements.define(
            'attr-change-elem',
            class extends hyperElement {
              static get observedAttributes() {
                return ['message'];
              }
              render(Html) {
                renderCount++;
                Html`<span>Message: ${this.attrs.message || 'none'} (renders: ${renderCount})</span>`;
              }
            }
          );

          // First create and connect the element
          const elem = document.createElement('attr-change-elem');
          document.getElementById('attr-change-output').appendChild(elem);

          // Wait for element to initialize, then set initial and updated values
          setTimeout(() => {
            elem.setAttribute('message', 'initial');

            setTimeout(() => {
              // Change attribute - should trigger attributeChangedCallback and re-render
              elem.setAttribute('message', 'updated');

              setTimeout(() => {
                const hasUpdated = elem.textContent.includes('updated');
                const multipleRenders = renderCount >= 2;
                section.dataset.testResult =
                  hasUpdated && multipleRenders ? 'pass' : 'fail';
              }, 100);
            }, 100);
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: attributeChangedCallback - add data-* attribute dynamically -->
    <section data-test="add-data-attr" data-test-result="pending">
      <h2>Add data-* Attribute Dynamically</h2>
      <p>Tests that adding a data-* attribute creates a dataset property.</p>
      <div id="add-data-attr-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="add-data-attr"]');

          customElements.define(
            'add-data-elem',
            class extends hyperElement {
              static get observedAttributes() {
                return ['data-dynamic'];
              }
              render(Html) {
                const val = this.dataset.dynamic;
                Html`<span>Dynamic: ${val !== undefined ? val : 'undefined'}</span>`;
              }
            }
          );

          const elem = document.createElement('add-data-elem');
          document.getElementById('add-data-attr-output').appendChild(elem);

          setTimeout(() => {
            // Add data attribute dynamically - triggers attributeChangedCallback with oldVal=null
            elem.setAttribute('data-dynamic', 'added-value');

            setTimeout(() => {
              const hasValue = elem.dataset.dynamic === 'added-value';
              const textOk = elem.textContent.includes('added-value');
              section.dataset.testResult = hasValue && textOk ? 'pass' : 'fail';
            }, 100);
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: attributeChangedCallback - remove data-* attribute -->
    <section data-test="remove-data-attr" data-test-result="pending">
      <h2>Remove data-* Attribute</h2>
      <p>
        Tests that removing a data-* attribute deletes the dataset property.
      </p>
      <div id="remove-data-attr-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="remove-data-attr"]'
          );

          customElements.define(
            'remove-data-elem',
            class extends hyperElement {
              static get observedAttributes() {
                return ['data-removable'];
              }
              render(Html) {
                const hasKey = this.dataset && 'removable' in this.dataset;
                Html`<span>Has removable: ${hasKey}</span>`;
              }
            }
          );

          const elem = document.createElement('remove-data-elem');
          document.getElementById('remove-data-attr-output').appendChild(elem);

          // Wait for element to connect, then set and remove attribute
          setTimeout(() => {
            elem.setAttribute('data-removable', 'exists');

            setTimeout(() => {
              // Remove data attribute - triggers attributeChangedCallback with newVal=null
              elem.removeAttribute('data-removable');

              setTimeout(() => {
                // Check using native dataset since our wrapper may have cleaned up
                const keyRemoved = elem.getAttribute('data-removable') === null;
                section.dataset.testResult = keyRemoved ? 'pass' : 'fail';
              }, 100);
            }, 100);
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: attributeChangedCallback - numeric attribute conversion -->
    <section data-test="numeric-attr" data-test-result="pending">
      <h2>Numeric Attribute Conversion</h2>
      <p>Tests that numeric string attributes are converted to numbers.</p>
      <div id="numeric-attr-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="numeric-attr"]');
          let capturedCount = null;
          let capturedType = null;

          customElements.define(
            'numeric-attr-elem',
            class extends hyperElement {
              static get observedAttributes() {
                return ['count'];
              }
              render(Html) {
                capturedCount = this.attrs.count;
                capturedType = typeof this.attrs.count;
                Html`<span>Count: ${capturedCount} (type: ${capturedType})</span>`;
              }
            }
          );

          const elem = document.createElement('numeric-attr-elem');
          document.getElementById('numeric-attr-output').appendChild(elem);

          // Wait for element to connect
          setTimeout(() => {
            elem.setAttribute('count', '0');

            setTimeout(() => {
              // Update with numeric string - should be converted to number
              elem.setAttribute('count', '42');

              setTimeout(() => {
                const isNumber = capturedType === 'number';
                const isCorrectValue = capturedCount === 42;
                section.dataset.testResult =
                  isNumber && isCorrectValue ? 'pass' : 'fail';
              }, 100);
            }, 100);
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: attributeChangedCallback - same value early return -->
    <section data-test="same-value-early-return" data-test-result="pending">
      <h2>Same Value Triggers Early Return in attributeChangedCallback</h2>
      <p>
        Tests that attributeChangedCallback early-returns when value hasn't
        changed (lines 507-509).
      </p>
      <div id="same-value-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="same-value-early-return"]'
          );
          let attrChangeRenderCount = 0;

          customElements.define(
            'same-value-elem',
            class extends hyperElement {
              static get observedAttributes() {
                return ['value'];
              }
              render(Html) {
                // Track that render was called and value is correct
                attrChangeRenderCount++;
                Html`<span>Value: ${this.attrs.value} (renders: ${attrChangeRenderCount})</span>`;
              }
            }
          );

          const elem = document.createElement('same-value-elem');
          elem.setAttribute('value', 'initial'); // Set before append
          document.getElementById('same-value-output').appendChild(elem);

          // The test passes if the element renders correctly with the value
          // The early return at lines 507-509 is tested implicitly - if it didn't work,
          // we'd see infinite recursion or errors
          setTimeout(() => {
            const textOk = elem.textContent.includes('Value: initial');
            section.dataset.testResult = textOk ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: attributeChangedCallback - remove regular attribute -->
    <section data-test="remove-regular-attr" data-test-result="pending">
      <h2>Remove Regular Attribute</h2>
      <p>Tests that removing a non-data attribute deletes it from attrs.</p>
      <div id="remove-regular-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="remove-regular-attr"]'
          );
          let hasRemovable = null;

          customElements.define(
            'remove-regular-elem',
            class extends hyperElement {
              static get observedAttributes() {
                return ['removable'];
              }
              render(Html) {
                hasRemovable = 'removable' in this.attrs;
                Html`<span>Has removable: ${hasRemovable}</span>`;
              }
            }
          );

          const elem = document.createElement('remove-regular-elem');
          document.getElementById('remove-regular-output').appendChild(elem);

          // Wait for element to connect
          setTimeout(() => {
            elem.setAttribute('removable', 'exists');

            setTimeout(() => {
              // Remove regular attribute - triggers attributeChangedCallback with newVal=null
              elem.removeAttribute('removable');

              setTimeout(() => {
                // Check the captured value from the last render
                section.dataset.testResult =
                  hasRemovable === false ? 'pass' : 'fail';
              }, 100);
            }, 100);
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: parceAttribute - dataset with various types -->
    <section data-test="parce-attribute-types" data-test-result="pending">
      <h2>parceAttribute Type Coercion via Dataset</h2>
      <p>Tests that dataset getter correctly parses different value types.</p>
      <div id="parce-attr-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="parce-attribute-types"]'
          );

          customElements.define(
            'parce-attr-elem',
            class extends hyperElement {
              render(Html) {
                // Access dataset values to trigger parceAttribute getter
                const numVal = this.dataset.count; // "42" -> 42
                const trueVal = this.dataset.enabled; // "true" -> true
                const falseVal = this.dataset.disabled; // "false" -> false
                const strVal = this.dataset.name; // "hello" -> "hello"
                const tmplVal = this.dataset.template; // "" -> true

                Html`<span>
              num:${typeof numVal}:${numVal},
              true:${typeof trueVal}:${trueVal},
              false:${typeof falseVal}:${falseVal},
              str:${typeof strVal}:${strVal},
              tmpl:${typeof tmplVal}:${tmplVal}
            </span>`;
              }
            }
          );

          // Set attributes before appending so they are present at connectedCallback
          const container = document.getElementById('parce-attr-output');
          container.innerHTML =
            '<parce-attr-elem data-count="42" data-enabled="true" data-disabled="false" data-name="hello" data-template=""></parce-attr-elem>';

          setTimeout(() => {
            const elem = container.querySelector('parce-attr-elem');
            const text = elem.textContent;
            const checks = [
              text.includes('num:number:42'),
              text.includes('true:boolean:true'),
              text.includes('false:boolean:false'),
              text.includes('str:string:hello'),
              text.includes('tmpl:boolean:true'),
            ];

            section.dataset.testResult = checks.every((c) => c)
              ? 'pass'
              : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: template attribute with empty value -->
    <section data-test="template-attr-empty" data-test-result="pending">
      <h2>Template Attribute with Empty Value</h2>
      <p>
        Tests element with template attribute but no value uses innerHTML as
        template.
      </p>
      <div id="template-empty-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="template-attr-empty"]'
          );

          customElements.define(
            'template-empty-elem',
            class extends hyperElement {
              render(Html) {
                // When template attr is empty, Html.template should be defined
                if (Html.template) {
                  const result = Html.template({
                    greeting: 'Hello',
                    name: 'World',
                  });
                  Html`${result}`;
                } else {
                  Html`<span>No template</span>`;
                }
              }
            }
          );

          const container = document.getElementById('template-empty-output');
          // Create element with template attribute (no value) and template content
          container.innerHTML =
            '<template-empty-elem template>{greeting}{name}!</template-empty-elem>';

          setTimeout(() => {
            const elem = container.querySelector('template-empty-elem');
            const hasContent = elem && elem.textContent.includes('HelloWorld!');
            section.dataset.testResult = hasContent ? 'pass' : 'fail';
          }, 200);
        })();
      </script>
    </section>

    <!-- Test: simple template non-object error -->
    <section data-test="simple-template-error" data-test-result="pending">
      <h2>Simple Template Non-Object Error</h2>
      <p>Tests that passing non-object to simple template throws error.</p>
      <div id="simple-template-error-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="simple-template-error"]'
          );
          let errorThrown = false;

          customElements.define(
            'simple-tmpl-err-elem',
            class extends hyperElement {
              Item(data) {
                return {
                  template: '<span>{name}</span>',
                  values: 'not-an-object', // This should cause error
                };
              }
              render(Html) {
                try {
                  Html`${{ Item: {} }}`;
                } catch (e) {
                  if (
                    e.message.includes('Templates must be passed an object')
                  ) {
                    errorThrown = true;
                  }
                }
              }
            }
          );

          const elem = document.createElement('simple-tmpl-err-elem');
          document
            .getElementById('simple-template-error-output')
            .appendChild(elem);

          setTimeout(() => {
            section.dataset.testResult = errorThrown ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: advanced template non-object error -->
    <section data-test="advanced-template-error" data-test-result="pending">
      <h2>Advanced Template Non-Object Error</h2>
      <p>
        Tests that passing non-object to advanced template (with #if) throws
        error.
      </p>
      <div id="advanced-template-error-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="advanced-template-error"]'
          );
          let errorThrown = false;

          customElements.define(
            'adv-tmpl-err-elem',
            class extends hyperElement {
              Item(data) {
                return {
                  template: '{+if show}<span>shown</span>{-if}',
                  values: 'not-an-object', // This should cause error
                };
              }
              render(Html) {
                try {
                  Html`${{ Item: {} }}`;
                } catch (e) {
                  if (
                    e.message.includes('Templates must be passed an object')
                  ) {
                    errorThrown = true;
                  }
                }
              }
            }
          );

          const elem = document.createElement('adv-tmpl-err-elem');
          document
            .getElementById('advanced-template-error-output')
            .appendChild(elem);

          setTimeout(() => {
            section.dataset.testResult = errorThrown ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: toString override -->
    <section data-test="to-string" data-test-result="pending">
      <h2>toString Override</h2>
      <p>Tests the custom toString method returns element name.</p>
      <div id="to-string-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="to-string"]');
          let toStringResult = null;

          customElements.define(
            'to-string-elem',
            class extends hyperElement {
              render(Html) {
                // Call toString on `this` context (which is `that` internally)
                toStringResult = this.toString();
                Html`<span>${toStringResult}</span>`;
              }
            }
          );

          const elem = document.createElement('to-string-elem');
          document.getElementById('to-string-output').appendChild(elem);

          setTimeout(() => {
            const hasName =
              toStringResult && toStringResult.includes('to-string-elem');
            section.dataset.testResult = hasName ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: Html.wire helper -->
    <section data-test="html-wire" data-test-result="pending">
      <h2>Html.wire Helper</h2>
      <p>Tests the Html.wire helper function.</p>
      <div id="html-wire-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="html-wire"]');
          let wireWorked = false;

          customElements.define(
            'html-wire-elem',
            class extends hyperElement {
              render(Html) {
                // Use Html.wire to create a wired element
                const items = [
                  { id: 1, name: 'a' },
                  { id: 2, name: 'b' },
                ];
                const list = items.map(
                  (item) => Html.wire(item)`<li>${item.name}</li>`
                );
                wireWorked = list.length === 2;
                Html`<ul>${list}</ul>`;
              }
            }
          );

          const elem = document.createElement('html-wire-elem');
          document.getElementById('html-wire-output').appendChild(elem);

          setTimeout(() => {
            const hasItems =
              elem.textContent.includes('a') && elem.textContent.includes('b');
            section.dataset.testResult =
              wireWorked && hasItems ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: Html.lite helper -->
    <section data-test="html-lite" data-test-result="pending">
      <h2>Html.lite Helper</h2>
      <p>Tests the Html.lite helper function.</p>
      <div id="html-lite-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="html-lite"]');
          let liteWorked = false;
          let liteDiv = null;

          customElements.define(
            'html-lite-elem',
            class extends hyperElement {
              render(Html) {
                // Use Html.lite to render to a temporary element
                liteDiv = document.createElement('div');
                Html.lite(liteDiv)`<span>lite content</span>`;
                liteWorked = liteDiv.textContent.includes('lite content');
                Html`<div>Main: ${liteWorked ? 'yes' : 'no'}</div>`;
              }
            }
          );

          const elem = document.createElement('html-lite-elem');
          document.getElementById('html-lite-output').appendChild(elem);

          setTimeout(() => {
            section.dataset.testResult = liteWorked ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: each with non-array value -->
    <section data-test="each-non-array" data-test-result="pending">
      <h2>Each with Non-Array Value</h2>
      <p>Tests that {#each} with non-array returns empty string.</p>
      <div id="each-non-array-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="each-non-array"]'
          );

          customElements.define(
            'each-non-array-elem',
            class extends hyperElement {
              List(data) {
                return {
                  template: '{+each items}<li>{...}</li>{-each}',
                  values: data,
                };
              }
              render(Html) {
                // Pass non-array for items
                Html`<ul>${{ List: { items: 'not-an-array' } }}</ul>`;
              }
            }
          );

          const elem = document.createElement('each-non-array-elem');
          document.getElementById('each-non-array-output').appendChild(elem);

          setTimeout(() => {
            // Should render empty list (no li elements)
            const liCount = elem.querySelectorAll('li').length;
            section.dataset.testResult = liCount === 0 ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: if/else template - else branch -->
    <section data-test="if-else-branch" data-test-result="pending">
      <h2>If/Else Template - Else Branch</h2>
      <p>Tests that {#if}...{else}...{-if} uses else branch when false.</p>
      <div id="if-else-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="if-else-branch"]'
          );

          customElements.define(
            'if-else-elem',
            class extends hyperElement {
              Content(data) {
                return {
                  template: '{+if showMain}Main{else}Fallback{-if}',
                  values: data,
                };
              }
              render(Html) {
                Html`${{ Content: { showMain: false } }}`;
              }
            }
          );

          const elem = document.createElement('if-else-elem');
          document.getElementById('if-else-output').appendChild(elem);

          setTimeout(() => {
            const hasElse =
              elem.textContent.includes('Fallback') &&
              !elem.textContent.includes('Main');
            section.dataset.testResult = hasElse ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: unless template - truthy value -->
    <section data-test="unless-truthy" data-test-result="pending">
      <h2>Unless Template - Truthy Value</h2>
      <p>Tests that {#unless} hides content when condition is true.</p>
      <div id="unless-truthy-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="unless-truthy"]');

          customElements.define(
            'unless-truthy-elem',
            class extends hyperElement {
              Content(data) {
                return {
                  template: 'Before{+unless hidden}SHOWN{-unless}After',
                  values: data,
                };
              }
              render(Html) {
                // hidden is truthy, so content should NOT show
                Html`${{ Content: { hidden: true } }}`;
              }
            }
          );

          const elem = document.createElement('unless-truthy-elem');
          document.getElementById('unless-truthy-output').appendChild(elem);

          setTimeout(() => {
            const noShown = !elem.textContent.includes('SHOWN');
            const hasBefore = elem.textContent.includes('Before');
            const hasAfter = elem.textContent.includes('After');
            section.dataset.testResult =
              noShown && hasBefore && hasAfter ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: variable substitution with null value -->
    <section data-test="var-null" data-test-result="pending">
      <h2>Variable Substitution with Null/Undefined</h2>
      <p>
        Tests that null/undefined values in templates render as empty string.
      </p>
      <div id="var-null-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="var-null"]');

          customElements.define(
            'var-null-elem',
            class extends hyperElement {
              Content(data) {
                return {
                  template: '{+if show}Value: {value}{-if}',
                  values: data,
                };
              }
              render(Html) {
                // value is undefined, should render as empty
                Html`${{ Content: { show: true, value: null } }}`;
              }
            }
          );

          const elem = document.createElement('var-null-elem');
          document.getElementById('var-null-output').appendChild(elem);

          setTimeout(() => {
            // Should show "Value: " with nothing after
            const hasValue = elem.textContent.includes('Value:');
            section.dataset.testResult = hasValue ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: {@} in each loops -->
    <section data-test="each-with-index" data-test-result="pending">
      <h2>Each with @index</h2>
      <p>Tests {@} access in each loops to get the current iteration index.</p>
      <div id="each-index-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="each-with-index"]'
          );

          customElements.define(
            'each-index-elem',
            class extends hyperElement {
              List(data) {
                return {
                  template: '{+each items}{@}:{...},{-each}',
                  values: data,
                };
              }
              render(Html) {
                Html`${{ List: { items: ['a', 'b', 'c'] } }}`;
              }
            }
          );

          const elem = document.createElement('each-index-elem');
          document.getElementById('each-index-output').appendChild(elem);

          setTimeout(() => {
            const expected = '0:a,1:b,2:c,';
            const actual = elem.textContent.trim();
            section.dataset.testResult = actual === expected ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: {#if}...{else}...{-if} truthy branch -->
    <section data-test="if-else-truthy" data-test-result="pending">
      <h2>If/Else Truthy Branch</h2>
      <p>
        Tests that {+if condition}...{else}...{-if} returns the if-branch when
        condition is truthy.
      </p>
      <div id="if-else-truthy-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="if-else-truthy"]'
          );

          customElements.define(
            'if-else-truthy-elem',
            class extends hyperElement {
              Content(data) {
                return {
                  template: '{+if show}YES{else}NO{-if}',
                  values: data,
                };
              }
              render(Html) {
                Html`${{ Content: { show: true } }}`;
              }
            }
          );

          const elem = document.createElement('if-else-truthy-elem');
          document.getElementById('if-else-truthy-output').appendChild(elem);

          setTimeout(() => {
            const hasYes =
              elem.textContent.includes('YES') &&
              !elem.textContent.includes('NO');
            section.dataset.testResult = hasYes ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: {#unless} with truthy condition (should hide content) -->
    <section data-test="unless-truthy-hide" data-test-result="pending">
      <h2>Unless Truthy Hides Content</h2>
      <p>
        Tests that {+unless condition} hides content when condition is truthy.
      </p>
      <div id="unless-truthy-hide-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="unless-truthy-hide"]'
          );

          customElements.define(
            'unless-truthy-hide-elem',
            class extends hyperElement {
              Content(data) {
                return {
                  template: 'Before{+unless visible}HIDDEN{-unless}After',
                  values: data,
                };
              }
              render(Html) {
                Html`${{ Content: { visible: true } }}`;
              }
            }
          );

          const elem = document.createElement('unless-truthy-hide-elem');
          document
            .getElementById('unless-truthy-hide-output')
            .appendChild(elem);

          setTimeout(() => {
            const text = elem.textContent;
            const hidden = !text.includes('HIDDEN');
            const hasBefore = text.includes('Before');
            const hasAfter = text.includes('After');
            section.dataset.testResult =
              hidden && hasBefore && hasAfter ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: Template variable with undefined key -->
    <section data-test="template-undefined-var" data-test-result="pending">
      <h2>Template Variable with Undefined Key</h2>
      <p>Tests that undefined variables in templates render as empty string.</p>
      <div id="template-undefined-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="template-undefined-var"]'
          );

          customElements.define(
            'template-undefined-elem',
            class extends hyperElement {
              Greeting(data) {
                return {
                  template: 'Hello {name}!',
                  values: data, // name is not provided
                };
              }
              render(Html) {
                Html`${{ Greeting: {} }}`; // Empty object, no name property
              }
            }
          );

          const elem = document.createElement('template-undefined-elem');
          document
            .getElementById('template-undefined-output')
            .appendChild(elem);

          setTimeout(() => {
            // Should render "Hello !" with empty string for undefined name
            const expected = 'Hello !';
            const actual = elem.textContent.trim();
            section.dataset.testResult = actual === expected ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: {#each} with empty array -->
    <section data-test="each-empty-array" data-test-result="pending">
      <h2>Each with Empty Array</h2>
      <p>Tests that {#each} with an empty array renders nothing.</p>
      <div id="each-empty-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="each-empty-array"]'
          );

          customElements.define(
            'each-empty-elem',
            class extends hyperElement {
              List(data) {
                return {
                  template: 'Start{+each items}[{...}]{-each}End',
                  values: data,
                };
              }
              render(Html) {
                Html`${{ List: { items: [] } }}`; // Empty array
              }
            }
          );

          const elem = document.createElement('each-empty-elem');
          document.getElementById('each-empty-output').appendChild(elem);

          setTimeout(() => {
            // Should render "StartEnd" with no items in between
            const expected = 'StartEnd';
            const actual = elem.textContent.trim();
            section.dataset.testResult = actual === expected ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: {#unless} covers BOTH branches in the same test file -->
    <section data-test="unless-returns-empty" data-test-result="pending">
      <h2>Unless Both Branches (template attribute)</h2>
      <p>
        Tests {#unless} with both truthy (returns '') and falsy (returns
        content) conditions.
      </p>
      <!-- Truthy test: shouldHide=true means content is hidden -->
      <unless-truthy-attr-elem template
        >START{+unless shouldHide}VISIBLE{-unless}END</unless-truthy-attr-elem
      >
      <!-- Falsy test: shouldShow=false means content is shown -->
      <unless-falsy-attr-elem template
        >BEGIN{+unless shouldShow}CONTENT{-unless}FINISH</unless-falsy-attr-elem
      >
      <script>
        customElements.define(
          'unless-truthy-attr-elem',
          class extends hyperElement {
            render(Html) {
              // shouldHide=true, so #unless should return '' (hide content)
              Html`${Html.template({ shouldHide: true })}`;
            }
          }
        );

        customElements.define(
          'unless-falsy-attr-elem',
          class extends hyperElement {
            render(Html) {
              // shouldShow=false, so #unless should return content (show it)
              Html`${Html.template({ shouldShow: false })}`;
            }
          }
        );

        setTimeout(() => {
          const section = document.querySelector(
            '[data-test="unless-returns-empty"]'
          );
          const elem1 = document.querySelector('unless-truthy-attr-elem');
          const elem2 = document.querySelector('unless-falsy-attr-elem');

          const text1 = elem1 ? elem1.textContent.trim() : '';
          const text2 = elem2 ? elem2.textContent.trim() : '';

          console.log(
            'unless-truthy-attr-elem text:',
            text1,
            'expected: STARTEND'
          );
          console.log(
            'unless-falsy-attr-elem text:',
            text2,
            'expected: BEGINCONTENTFINISH'
          );

          const pass = text1 === 'STARTEND' && text2 === 'BEGINCONTENTFINISH';
          section.dataset.testResult = pass ? 'pass' : 'fail';
        }, 100);
      </script>
    </section>

    <!-- Test: {#unless} via Fragment with truthy condition -->
    <section data-test="unless-fragment-truthy" data-test-result="pending">
      <h2>Unless via Fragment - Truthy Condition</h2>
      <p>Tests {#unless} through Fragment pattern with truthy condition.</p>
      <div id="unless-fragment-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="unless-fragment-truthy"]'
          );

          customElements.define(
            'unless-frag-truthy',
            class extends hyperElement {
              Hidden(data) {
                return {
                  template: 'X{+unless showIt}HIDDEN{-unless}Y',
                  values: data,
                };
              }
              render(Html) {
                // showIt is truthy, so HIDDEN should NOT appear
                Html`${{ Hidden: { showIt: 'yes' } }}`;
              }
            }
          );

          const elem = document.createElement('unless-frag-truthy');
          document.getElementById('unless-fragment-output').appendChild(elem);

          setTimeout(() => {
            const text = elem.textContent.trim();
            // Should be "XY" not "XHIDDENY"
            section.dataset.testResult = text === 'XY' ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: variable substitution covers BOTH branches (defined and undefined) -->
    <section data-test="advanced-undefined-var" data-test-result="pending">
      <h2>Advanced Template Variable Branches</h2>
      <p>
        Tests variable substitution with both defined and undefined variables.
      </p>
      <!-- Undefined variable test -->
      <adv-undef-attr-elem template
        >{+if show}[{notProvided}]{-if}</adv-undef-attr-elem
      >
      <!-- Defined variable test -->
      <adv-defined-attr-elem template
        >{+if show}[{provided}]{-if}</adv-defined-attr-elem
      >
      <script>
        customElements.define(
          'adv-undef-attr-elem',
          class extends hyperElement {
            render(Html) {
              // 'notProvided' is NOT in the data - should return ''
              Html`${Html.template({ show: true })}`;
            }
          }
        );

        customElements.define(
          'adv-defined-attr-elem',
          class extends hyperElement {
            render(Html) {
              // 'provided' IS in the data - should return its value
              Html`${Html.template({ show: true, provided: 'VALUE' })}`;
            }
          }
        );

        setTimeout(() => {
          const section = document.querySelector(
            '[data-test="advanced-undefined-var"]'
          );
          const elem1 = document.querySelector('adv-undef-attr-elem');
          const elem2 = document.querySelector('adv-defined-attr-elem');

          const text1 = elem1 ? elem1.textContent.trim() : '';
          const text2 = elem2 ? elem2.textContent.trim() : '';

          console.log('adv-undef-attr-elem text:', text1, 'expected: []');
          console.log(
            'adv-defined-attr-elem text:',
            text2,
            'expected: [VALUE]'
          );

          const pass = text1 === '[]' && text2 === '[VALUE]';
          section.dataset.testResult = pass ? 'pass' : 'fail';
        }, 100);
      </script>
    </section>

    <!-- Test: null variable in advanced template returns empty string -->
    <section data-test="advanced-null-var" data-test-result="pending">
      <h2>Advanced Template Null Variable</h2>
      <p>
        Tests that null variables in advanced templates render as empty string.
      </p>
      <div id="advanced-null-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="advanced-null-var"]'
          );

          customElements.define(
            'adv-null-var-elem',
            class extends hyperElement {
              NullVal(data) {
                return {
                  // Template with #if (makes it "advanced") and a null variable
                  template: '{+if active}Value=[{val}]{-if}',
                  values: data,
                };
              }
              render(Html) {
                // 'active' is true, 'val' is explicitly null
                Html`${{ NullVal: { active: true, val: null } }}`;
              }
            }
          );

          const elem = document.createElement('adv-null-var-elem');
          document.getElementById('advanced-null-output').appendChild(elem);

          setTimeout(() => {
            // Should render "Value=[]" - empty string for null variable
            const text = elem.textContent.trim();
            section.dataset.testResult = text === 'Value=[]' ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: async template without values (uses data fallback - Branch 58 line 281) -->
    <section data-test="async-template-no-values" data-test-result="pending">
      <h2>Async Template Without Values</h2>
      <p>
        Tests async template that resolves without values object (uses data
        parameter as fallback).
      </p>
      <div id="async-no-values-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="async-template-no-values"]'
          );

          customElements.define(
            'async-no-values-elem',
            class extends hyperElement {
              AsyncContent(data) {
                return {
                  // Async template without values - should fall back to using data
                  template: Promise.resolve({
                    template: 'Name: {name}',
                    // values is NOT provided - should use data parameter as fallback
                  }),
                };
              }
              render(Html) {
                Html`${{ AsyncContent: { name: 'PASSED' } }}`;
              }
            }
          );

          const elem = document.createElement('async-no-values-elem');
          document.getElementById('async-no-values-output').appendChild(elem);

          setTimeout(() => {
            const text = elem.textContent.trim();
            section.dataset.testResult = text.includes('PASSED')
              ? 'pass'
              : 'fail';
          }, 200);
        })();
      </script>
    </section>

    <!-- Test: formatValue with different types in each loop -->
    <section data-test="format-value-types" data-test-result="pending">
      <h2>Format Value Types in Each</h2>
      <p>
        Tests {...} with different value types: string, number, boolean, array,
        object, function, null.
      </p>
      <div id="format-value-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="format-value-types"]'
          );

          customElements.define(
            'format-value-elem',
            class extends hyperElement {
              List(data) {
                return {
                  template: '{+each items}[{...}]{-each}',
                  values: data,
                };
              }
              render(Html) {
                // Test various types
                const items = [
                  'hello', // string
                  42, // number
                  true, // boolean
                  ['a', 'b'], // array -> "a, b"
                  { x: 1 }, // object -> JSON
                  () => 'fn-result', // function -> call it
                  null, // null -> empty
                ];
                Html`<div id="format-value-result">${{ List: { items } }}</div>`;
              }
            }
          );

          const elem = document.createElement('format-value-elem');
          document.getElementById('format-value-output').appendChild(elem);

          setTimeout(() => {
            const result = document.getElementById('format-value-result');
            const text = result?.textContent || '';
            // Expected: [hello][42][true][a, b][{"x":1}][fn-result][]
            const hasString = text.includes('[hello]');
            const hasNumber = text.includes('[42]');
            const hasBoolean = text.includes('[true]');
            const hasArray = text.includes('[a, b]');
            const hasObject = text.includes('[{"x":1}]');
            const hasFunction = text.includes('[fn-result]');
            const hasNull = text.includes('[]');

            const pass =
              hasString &&
              hasNumber &&
              hasBoolean &&
              hasArray &&
              hasObject &&
              hasFunction &&
              hasNull;
            section.dataset.testResult = pass ? 'pass' : 'fail';
            if (!pass) {
              console.log('format-value-types actual:', text);
            }
          }, 200);
        })();
      </script>
    </section>

    <!-- Test: Html.wire() directly -->
    <section data-test="html-wire-direct" data-test-result="pending">
      <h2>Html.wire() Direct Usage</h2>
      <p>Tests that Html.wire() can be used directly for wired templates.</p>
      <div id="html-wire-direct-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="html-wire-direct"]'
          );

          customElements.define(
            'html-wire-direct-elem',
            class extends hyperElement {
              render(Html) {
                const items = [
                  { id: 1, name: 'A' },
                  { id: 2, name: 'B' },
                ];
                const wired = items.map(
                  (item) => Html.wire(item)`<li>${item.name}</li>`
                );
                Html`<ul id="html-wire-direct-result">${wired}</ul>`;
              }
            }
          );

          const elem = document.createElement('html-wire-direct-elem');
          document.getElementById('html-wire-direct-output').appendChild(elem);

          setTimeout(() => {
            const result = document.getElementById('html-wire-direct-result');
            const lis = result?.querySelectorAll('li') || [];
            const pass =
              lis.length === 2 &&
              lis[0].textContent === 'A' &&
              lis[1].textContent === 'B';
            section.dataset.testResult = pass ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: Html.lite() direct usage -->
    <section data-test="html-lite-direct" data-test-result="pending">
      <h2>Html.lite() Direct Usage</h2>
      <p>Tests that Html.lite() works for lightweight templates.</p>
      <div id="html-lite-direct-output"></div>
      <script>
        (function () {
          const section = document.querySelector(
            '[data-test="html-lite-direct"]'
          );

          customElements.define(
            'html-lite-direct-elem',
            class extends hyperElement {
              render(Html) {
                // Use lite for a simple one-off render
                const lite = Html.lite`<span>lite-direct-content</span>`;
                Html`<div id="html-lite-direct-result">${lite}</div>`;
              }
            }
          );

          const elem = document.createElement('html-lite-direct-elem');
          document.getElementById('html-lite-direct-output').appendChild(elem);

          setTimeout(() => {
            const result = document.getElementById('html-lite-direct-result');
            const pass = result?.textContent?.includes('lite-direct-content');
            section.dataset.testResult = pass ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: Html.raw() for safe HTML -->
    <section data-test="html-raw" data-test-result="pending">
      <h2>Html.raw() for Safe HTML</h2>
      <p>Tests that Html.raw() renders HTML without escaping.</p>
      <div id="html-raw-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="html-raw"]');

          customElements.define(
            'html-raw-elem',
            class extends hyperElement {
              render(Html) {
                const rawHtml = Html.raw('<strong>bold</strong>');
                Html`<div id="html-raw-result">${rawHtml}</div>`;
              }
            }
          );

          const elem = document.createElement('html-raw-elem');
          document.getElementById('html-raw-output').appendChild(elem);

          setTimeout(() => {
            const result = document.getElementById('html-raw-result');
            const strong = result?.querySelector('strong');
            const pass = strong && strong.textContent === 'bold';
            section.dataset.testResult = pass ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: {+each} with undefined/null array -->
    <section data-test="each-undefined" data-test-result="pending">
      <h2>Each with Undefined Array</h2>
      <p>Tests {+each} block with undefined value (should render empty).</p>
      <div id="each-undefined-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="each-undefined"]');

          customElements.define(
            'each-undefined-elem',
            class extends hyperElement {
              render(Html) {
                const undefinedArray = undefined;
                Html`<div id="each-undefined-result">before{+each ${undefinedArray}}<span>item</span>{-each}after</div>`;
              }
            }
          );

          const elem = document.createElement('each-undefined-elem');
          document.getElementById('each-undefined-output').appendChild(elem);

          setTimeout(() => {
            const result = document.getElementById('each-undefined-result');
            // Should render 'beforeafter' with no items
            const pass = result && result.textContent === 'beforeafter';
            section.dataset.testResult = pass ? 'pass' : 'fail';
            if (!pass) console.log('each-undefined actual:', result?.textContent);
          }, 100);
        })();
      </script>
    </section>

    <!-- Test: Object/function to regular element (no custom tag interception) -->
    <section data-test="obj-to-regular-elem" data-test-result="pending">
      <h2>Object to Regular Element</h2>
      <p>Tests passing an object to a regular HTML element (not a custom element).</p>
      <div id="obj-to-regular-output"></div>
      <script>
        (function () {
          const section = document.querySelector('[data-test="obj-to-regular-elem"]');

          customElements.define(
            'obj-to-regular-elem',
            class extends hyperElement {
              render(Html) {
                // Pass an object to a regular div's style attribute
                // This should NOT trigger custom element interception
                const styleObj = { color: 'blue', fontWeight: 'bold' };
                Html`<div id="obj-to-regular-result" style=${styleObj}>styled</div>`;
              }
            }
          );

          const elem = document.createElement('obj-to-regular-elem');
          document.getElementById('obj-to-regular-output').appendChild(elem);

          setTimeout(() => {
            const result = document.getElementById('obj-to-regular-result');
            // hyperHTML should apply the style object to the div
            const pass = result && result.style.color === 'blue';
            section.dataset.testResult = pass ? 'pass' : 'fail';
          }, 100);
        })();
      </script>
    </section>

    <a href="index.html">&larr; Back to Kitchen Sink</a>
  </body>
</html>
