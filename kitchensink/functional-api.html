<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Functional API - hyper-element Kitchen Sink</title>
    <script src="test-loader.js"></script>
    <style>
      body {
        font-family: sans-serif;
        padding: 2rem;
      }
      section {
        margin: 2rem 0;
        padding: 1rem;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      section[data-test-result='pass'] {
        border-color: green;
        background: #f0fff0;
      }
      section[data-test-result='fail'] {
        border-color: red;
        background: #fff0f0;
      }
      h1 {
        border-bottom: 2px solid #333;
      }
      h2 {
        margin-top: 0;
      }
      pre {
        background: #f5f5f5;
        padding: 1rem;
        overflow-x: auto;
      }
    </style>
  </head>
  <body>
    <h1>Functional API</h1>
    <p>
      Demonstrates the functional API for defining custom elements without
      classes. All four signatures are covered.
    </p>

    <!-- Test 1: Full definition with tag (auto-registers) -->
    <section data-test="definition-with-tag" data-test-result="pending">
      <h2>1. Definition with Tag (auto-registers)</h2>
      <p>Full definition object with automatic registration.</p>
      <pre><code>hyperElement('func-counter', {
  observedAttributes: ['count'],
  render: (Html, ctx) => Html`Count: ${ctx.attrs.count || 0}`
});</code></pre>
      <div id="output-1"></div>
      <script>
        hyperElement('func-counter', {
          observedAttributes: ['count'],
          render: (Html, ctx) => Html`Count: ${ctx.attrs.count || 0}`,
        });

        const elem1 = document.createElement('func-counter');
        elem1.setAttribute('count', '42');
        document.getElementById('output-1').appendChild(elem1);

        requestAnimationFrame(() => {
          const section = document.querySelector(
            '[data-test="definition-with-tag"]'
          );
          if (elem1.textContent.includes('Count: 42')) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        });
      </script>
    </section>

    <!-- Test 2: Shorthand with tag (auto-registers) -->
    <section data-test="shorthand-with-tag" data-test-result="pending">
      <h2>2. Shorthand with Tag (auto-registers)</h2>
      <p>Just a render function with automatic registration.</p>
      <pre><code>hyperElement('func-hello', (Html, ctx) =>
  Html`Hello, ${ctx.attrs.name || 'World'}!`
);</code></pre>
      <div id="output-2"></div>
      <script>
        hyperElement(
          'func-hello',
          (Html, ctx) => Html`Hello, ${ctx.attrs.name || 'World'}!`
        );

        const elem2 = document.createElement('func-hello');
        elem2.setAttribute('name', 'Functional');
        document.getElementById('output-2').appendChild(elem2);

        requestAnimationFrame(() => {
          const section = document.querySelector(
            '[data-test="shorthand-with-tag"]'
          );
          if (elem2.textContent.includes('Hello, Functional!')) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        });
      </script>
    </section>

    <!-- Test 3: Definition without tag (manual registration) -->
    <section data-test="definition-no-tag" data-test-result="pending">
      <h2>3. Definition without Tag (manual registration)</h2>
      <p>Returns class for use with customElements.define().</p>
      <pre><code>const ManualElem = hyperElement({
  render: (Html, ctx) => Html`Manual: ${ctx.attrs.value}`
});
customElements.define('func-manual', ManualElem);</code></pre>
      <div id="output-3"></div>
      <script>
        const ManualElem = hyperElement({
          render: (Html, ctx) => Html`Manual: ${ctx.attrs.value}`,
        });
        customElements.define('func-manual', ManualElem);

        const elem3 = document.createElement('func-manual');
        elem3.setAttribute('value', 'works');
        document.getElementById('output-3').appendChild(elem3);

        requestAnimationFrame(() => {
          const section = document.querySelector(
            '[data-test="definition-no-tag"]'
          );
          if (elem3.textContent.includes('Manual: works')) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        });
      </script>
    </section>

    <!-- Test 4: Shorthand without tag (manual registration) -->
    <section data-test="shorthand-no-tag" data-test-result="pending">
      <h2>4. Shorthand without Tag (manual registration)</h2>
      <p>Just a render function, returns class for manual registration.</p>
      <pre><code>const SimpleElem = hyperElement((Html, ctx) =>
  Html`Simple: ${ctx.attrs.msg}`
);
customElements.define('func-simple', SimpleElem);</code></pre>
      <div id="output-4"></div>
      <script>
        const SimpleElem = hyperElement(
          (Html, ctx) => Html`Simple: ${ctx.attrs.msg}`
        );
        customElements.define('func-simple', SimpleElem);

        const elem4 = document.createElement('func-simple');
        elem4.setAttribute('msg', 'shorthand');
        document.getElementById('output-4').appendChild(elem4);

        requestAnimationFrame(() => {
          const section = document.querySelector(
            '[data-test="shorthand-no-tag"]'
          );
          if (elem4.textContent.includes('Simple: shorthand')) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        });
      </script>
    </section>

    <!-- Test 5: With setup and teardown -->
    <section data-test="setup-teardown" data-test-result="pending">
      <h2>5. With Setup and Teardown</h2>
      <p>Lifecycle management with setup returning a teardown function.</p>
      <pre><code>hyperElement('func-timer', {
  setup: (ctx, onNext) => {
    let count = 0;
    const render = onNext(() => ({ count }));
    const interval = setInterval(() => { count++; render(); }, 100);
    return () => clearInterval(interval);
  },
  render: (Html, ctx, store) => Html`Timer: ${store?.count || 0}`
});</code></pre>
      <div id="output-5"></div>
      <script>
        hyperElement('func-timer', {
          setup: (ctx, onNext) => {
            let count = 0;
            const render = onNext(() => ({ count }));
            const interval = setInterval(() => {
              count++;
              render();
            }, 100);
            return () => clearInterval(interval);
          },
          render: (Html, ctx, store) => Html`Timer: ${store?.count || 0}`,
        });

        const elem5 = document.createElement('func-timer');
        document.getElementById('output-5').appendChild(elem5);

        setTimeout(() => {
          const section = document.querySelector(
            '[data-test="setup-teardown"]'
          );
          const text = elem5.textContent;
          // After 350ms, count should be at least 2
          if (text.includes('Timer:') && parseInt(text.split(':')[1]) >= 2) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
          // Remove to test teardown (cleanup interval)
          elem5.remove();
        }, 350);
      </script>
    </section>

    <!-- Test 6: With methods and events -->
    <section data-test="methods-events" data-test-result="pending">
      <h2>6. With Methods and Events</h2>
      <p>Custom methods with context passed as first argument.</p>
      <pre><code>hyperElement('func-clicker', {
  setup: (ctx, onNext) => {
    const render = onNext(() => ({ clicks: 0 }));
    ctx.increment = () => {
      ctx.store.clicks++;
      render();
    };
  },
  handleClick: (ctx, event) => ctx.increment(),
  render: (Html, ctx, store) =>
    Html`<button onclick=${ctx.handleClick}>Clicks: ${store?.clicks || 0}</button>`
});</code></pre>
      <div id="output-6"></div>
      <script>
        hyperElement('func-clicker', {
          setup: (ctx, onNext) => {
            const store = { clicks: 0 };
            const render = onNext(() => store);
            ctx.increment = () => {
              store.clicks++;
              render();
            };
          },
          handleClick: (ctx, event) => ctx.increment(),
          render: (Html, ctx, store) =>
            Html`<button onclick=${ctx.handleClick}>Clicks: ${store?.clicks || 0}</button>`,
        });

        const elem6 = document.createElement('func-clicker');
        document.getElementById('output-6').appendChild(elem6);

        setTimeout(() => {
          const btn = elem6.querySelector('button');
          btn.click();
          btn.click();

          setTimeout(() => {
            const section = document.querySelector(
              '[data-test="methods-events"]'
            );
            if (btn.textContent.includes('Clicks: 2')) {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          }, 50);
        }, 50);
      </script>
    </section>

    <!-- Test 7: Class-based backward compatibility -->
    <section data-test="class-compat" data-test-result="pending">
      <h2>7. Class-based Backward Compatibility</h2>
      <p>Traditional class extension still works.</p>
      <pre><code>class ClassicElement extends hyperElement {
  render(Html) {
    Html`Classic: ${this.attrs.msg}`;
  }
}
customElements.define('func-classic', ClassicElement);</code></pre>
      <div id="output-7"></div>
      <script>
        class ClassicElement extends hyperElement {
          render(Html) {
            Html`Classic: ${this.attrs.msg}`;
          }
        }
        customElements.define('func-classic', ClassicElement);

        const elem7 = document.createElement('func-classic');
        elem7.setAttribute('msg', 'still works');
        document.getElementById('output-7').appendChild(elem7);

        requestAnimationFrame(() => {
          const section = document.querySelector('[data-test="class-compat"]');
          if (elem7.textContent.includes('Classic: still works')) {
            section.dataset.testResult = 'pass';
          } else {
            section.dataset.testResult = 'fail';
          }
        });
      </script>
    </section>

    <!-- Test 8: Observed attributes with functional API -->
    <section data-test="observed-attrs" data-test-result="pending">
      <h2>8. Observed Attributes</h2>
      <p>observedAttributes triggers re-render on attribute change.</p>
      <pre><code>hyperElement('func-observed', {
  observedAttributes: ['value'],
  render: (Html, ctx) => Html`Value: ${ctx.attrs.value}`
});</code></pre>
      <div id="output-8"></div>
      <script>
        hyperElement('func-observed', {
          observedAttributes: ['value'],
          render: (Html, ctx) => Html`Value: ${ctx.attrs.value}`,
        });

        const elem8 = document.createElement('func-observed');
        elem8.setAttribute('value', 'initial');
        document.getElementById('output-8').appendChild(elem8);

        requestAnimationFrame(() => {
          elem8.setAttribute('value', 'updated');

          requestAnimationFrame(() => {
            const section = document.querySelector(
              '[data-test="observed-attrs"]'
            );
            if (elem8.textContent.includes('Value: updated')) {
              section.dataset.testResult = 'pass';
            } else {
              section.dataset.testResult = 'fail';
            }
          });
        });
      </script>
    </section>

    <a href="index.html">&larr; Back to Kitchen Sink</a>
  </body>
</html>
