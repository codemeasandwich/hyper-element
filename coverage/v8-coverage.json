[
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 3
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 3
          },
          {
            "startOffset": 6350,
            "endOffset": 6365,
            "count": 0
          },
          {
            "startOffset": 6366,
            "endOffset": 6391,
            "count": 0
          },
          {
            "startOffset": 6429,
            "endOffset": 6470,
            "count": 0
          },
          {
            "startOffset": 6560,
            "endOffset": 6585,
            "count": 0
          },
          {
            "startOffset": 6621,
            "endOffset": 6647,
            "count": 0
          },
          {
            "startOffset": 6772,
            "endOffset": 6836,
            "count": 0
          },
          {
            "startOffset": 6875,
            "endOffset": 6896,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 3
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 6
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 3
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 3
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 0
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12923,
            "endOffset": 12954,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14133,
            "endOffset": 14156,
            "count": 2
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14319,
            "endOffset": 14373,
            "count": 3
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14390,
            "endOffset": 14702,
            "count": 3
          },
          {
            "startOffset": 14523,
            "endOffset": 14590,
            "count": 1
          },
          {
            "startOffset": 14590,
            "endOffset": 14679,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14925,
            "endOffset": 14956,
            "count": 2
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 3
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 2
          },
          {
            "startOffset": 15218,
            "endOffset": 15227,
            "count": 0
          },
          {
            "startOffset": 15228,
            "endOffset": 15387,
            "count": 0
          },
          {
            "startOffset": 15467,
            "endOffset": 15500,
            "count": 0
          },
          {
            "startOffset": 15512,
            "endOffset": 15572,
            "count": 0
          },
          {
            "startOffset": 15573,
            "endOffset": 15651,
            "count": 0
          },
          {
            "startOffset": 15709,
            "endOffset": 15765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 7
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2881,
            "endOffset": 3630,
            "count": 2
          },
          {
            "startOffset": 2980,
            "endOffset": 2990,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3012,
            "endOffset": 3613,
            "count": 5
          },
          {
            "startOffset": 3393,
            "endOffset": 3409,
            "count": 2
          },
          {
            "startOffset": 3411,
            "endOffset": 3577,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3449,
            "endOffset": 3565,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3803,
            "endOffset": 3912,
            "count": 1
          },
          {
            "startOffset": 3880,
            "endOffset": 3891,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4065,
            "endOffset": 4148,
            "count": 2
          },
          {
            "startOffset": 4127,
            "endOffset": 4136,
            "count": 1
          },
          {
            "startOffset": 4137,
            "endOffset": 4141,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4310,
            "endOffset": 4393,
            "count": 1
          },
          {
            "startOffset": 4372,
            "endOffset": 4376,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 7
          },
          {
            "startOffset": 4604,
            "endOffset": 5231,
            "count": 6
          },
          {
            "startOffset": 5231,
            "endOffset": 6262,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4669,
            "endOffset": 5221,
            "count": 6
          },
          {
            "startOffset": 4734,
            "endOffset": 4851,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5092,
            "endOffset": 5180,
            "count": 1
          },
          {
            "startOffset": 5161,
            "endOffset": 5165,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5370,
            "endOffset": 5595,
            "count": 3
          },
          {
            "startOffset": 5416,
            "endOffset": 5441,
            "count": 1
          },
          {
            "startOffset": 5442,
            "endOffset": 5504,
            "count": 1
          },
          {
            "startOffset": 5504,
            "endOffset": 5562,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5697,
            "endOffset": 5920,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5805,
            "endOffset": 5821,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5940,
            "endOffset": 6258,
            "count": 1
          },
          {
            "startOffset": 6006,
            "endOffset": 6169,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 7
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 14
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 7
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 7
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 1
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 7
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 7
          },
          {
            "startOffset": 15387,
            "endOffset": 15864,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 1
          },
          {
            "startOffset": 486,
            "endOffset": 555,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 4
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 4
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 9
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 5
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 1
          },
          {
            "startOffset": 7706,
            "endOffset": 9900,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 9821,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 4
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 1
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 4
          },
          {
            "startOffset": 10553,
            "endOffset": 10599,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 2
          },
          {
            "startOffset": 10821,
            "endOffset": 11174,
            "count": 1
          },
          {
            "startOffset": 11226,
            "endOffset": 11333,
            "count": 1
          },
          {
            "startOffset": 11333,
            "endOffset": 11377,
            "count": 0
          },
          {
            "startOffset": 11378,
            "endOffset": 11993,
            "count": 1
          },
          {
            "startOffset": 11499,
            "endOffset": 11649,
            "count": 0
          },
          {
            "startOffset": 11764,
            "endOffset": 11806,
            "count": 0
          },
          {
            "startOffset": 11969,
            "endOffset": 11975,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 4
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 2
          },
          {
            "startOffset": 15218,
            "endOffset": 15227,
            "count": 0
          },
          {
            "startOffset": 15228,
            "endOffset": 15387,
            "count": 0
          },
          {
            "startOffset": 15426,
            "endOffset": 15456,
            "count": 1
          },
          {
            "startOffset": 15467,
            "endOffset": 15500,
            "count": 1
          },
          {
            "startOffset": 15512,
            "endOffset": 15572,
            "count": 1
          },
          {
            "startOffset": 15573,
            "endOffset": 15864,
            "count": 1
          },
          {
            "startOffset": 15709,
            "endOffset": 15765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 4
          },
          {
            "startOffset": 486,
            "endOffset": 555,
            "count": 60
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 6
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 6
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 13
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 7
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 1
          },
          {
            "startOffset": 7706,
            "endOffset": 9900,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 9821,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 6
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 3
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 6
          },
          {
            "startOffset": 10553,
            "endOffset": 10599,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 7
          },
          {
            "startOffset": 10821,
            "endOffset": 11041,
            "count": 3
          },
          {
            "startOffset": 11041,
            "endOffset": 11174,
            "count": 4
          },
          {
            "startOffset": 11105,
            "endOffset": 11174,
            "count": 3
          },
          {
            "startOffset": 11226,
            "endOffset": 11256,
            "count": 3
          },
          {
            "startOffset": 11256,
            "endOffset": 11333,
            "count": 4
          },
          {
            "startOffset": 11333,
            "endOffset": 11377,
            "count": 3
          },
          {
            "startOffset": 11378,
            "endOffset": 11993,
            "count": 4
          },
          {
            "startOffset": 11499,
            "endOffset": 11649,
            "count": 0
          },
          {
            "startOffset": 11764,
            "endOffset": 11806,
            "count": 0
          },
          {
            "startOffset": 11962,
            "endOffset": 11969,
            "count": 1
          },
          {
            "startOffset": 11969,
            "endOffset": 11975,
            "count": 3
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 6
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 6
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 5
          },
          {
            "startOffset": 15218,
            "endOffset": 15227,
            "count": 0
          },
          {
            "startOffset": 15228,
            "endOffset": 15387,
            "count": 0
          },
          {
            "startOffset": 15426,
            "endOffset": 15456,
            "count": 4
          },
          {
            "startOffset": 15467,
            "endOffset": 15500,
            "count": 4
          },
          {
            "startOffset": 15512,
            "endOffset": 15572,
            "count": 4
          },
          {
            "startOffset": 15573,
            "endOffset": 15651,
            "count": 4
          },
          {
            "startOffset": 15651,
            "endOffset": 15864,
            "count": 1
          },
          {
            "startOffset": 15709,
            "endOffset": 15765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 1
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 1
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 2
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 1
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 1
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 0
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 1
          },
          {
            "startOffset": 15218,
            "endOffset": 15227,
            "count": 0
          },
          {
            "startOffset": 15228,
            "endOffset": 15387,
            "count": 0
          },
          {
            "startOffset": 15467,
            "endOffset": 15500,
            "count": 0
          },
          {
            "startOffset": 15512,
            "endOffset": 15572,
            "count": 0
          },
          {
            "startOffset": 15573,
            "endOffset": 15651,
            "count": 0
          },
          {
            "startOffset": 15709,
            "endOffset": 15765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 2
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 7
          },
          {
            "startOffset": 6350,
            "endOffset": 6365,
            "count": 0
          },
          {
            "startOffset": 6366,
            "endOffset": 6391,
            "count": 0
          },
          {
            "startOffset": 6429,
            "endOffset": 6470,
            "count": 0
          },
          {
            "startOffset": 6560,
            "endOffset": 6585,
            "count": 0
          },
          {
            "startOffset": 6621,
            "endOffset": 6647,
            "count": 0
          },
          {
            "startOffset": 6772,
            "endOffset": 6836,
            "count": 0
          },
          {
            "startOffset": 6875,
            "endOffset": 6896,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 2
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 4
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 2
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 2
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 0
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14133,
            "endOffset": 14156,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14319,
            "endOffset": 14373,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14390,
            "endOffset": 14702,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14925,
            "endOffset": 14956,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 2
          },
          {
            "startOffset": 15218,
            "endOffset": 15227,
            "count": 0
          },
          {
            "startOffset": 15228,
            "endOffset": 15387,
            "count": 0
          },
          {
            "startOffset": 15467,
            "endOffset": 15500,
            "count": 0
          },
          {
            "startOffset": 15512,
            "endOffset": 15572,
            "count": 0
          },
          {
            "startOffset": 15573,
            "endOffset": 15651,
            "count": 0
          },
          {
            "startOffset": 15709,
            "endOffset": 15765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 1
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 1
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 2
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 1
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 1
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 0
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 1
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 1
          },
          {
            "startOffset": 839,
            "endOffset": 852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 841,
            "endOffset": 852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 911,
            "endOffset": 1122,
            "count": 2
          },
          {
            "startOffset": 956,
            "endOffset": 1027,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 1
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 3
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 2
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 2
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 0
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 1
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 1
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 1
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 2
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 1
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 1
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 0
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 1
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 1
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 1
          },
          {
            "startOffset": 4604,
            "endOffset": 5231,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4669,
            "endOffset": 5221,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5370,
            "endOffset": 5595,
            "count": 3
          },
          {
            "startOffset": 5416,
            "endOffset": 5441,
            "count": 1
          },
          {
            "startOffset": 5442,
            "endOffset": 5504,
            "count": 1
          },
          {
            "startOffset": 5504,
            "endOffset": 5562,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5697,
            "endOffset": 5920,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5805,
            "endOffset": 5821,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5940,
            "endOffset": 6258,
            "count": 1
          },
          {
            "startOffset": 6006,
            "endOffset": 6169,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 1
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 2
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 1
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 1
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 1
          },
          {
            "startOffset": 15387,
            "endOffset": 15864,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 2
          },
          {
            "startOffset": 831,
            "endOffset": 838,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 841,
            "endOffset": 852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 911,
            "endOffset": 1122,
            "count": 5
          },
          {
            "startOffset": 1027,
            "endOffset": 1114,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 3
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 6
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 4
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 5
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 0
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 2
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 3
          },
          {
            "startOffset": 1491,
            "endOffset": 1498,
            "count": 2
          },
          {
            "startOffset": 1498,
            "endOffset": 1647,
            "count": 1
          },
          {
            "startOffset": 1647,
            "endOffset": 1818,
            "count": 0
          },
          {
            "startOffset": 1818,
            "endOffset": 1957,
            "count": 1
          },
          {
            "startOffset": 1957,
            "endOffset": 2028,
            "count": 0
          },
          {
            "startOffset": 2028,
            "endOffset": 2199,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 1
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 1
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 2
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 1
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 2
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 0
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 1
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 1
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 1
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 3
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 2
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 1
          },
          {
            "startOffset": 9900,
            "endOffset": 9963,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 9821,
            "count": 1
          },
          {
            "startOffset": 7851,
            "endOffset": 7865,
            "count": 0
          },
          {
            "startOffset": 7881,
            "endOffset": 7894,
            "count": 0
          },
          {
            "startOffset": 7971,
            "endOffset": 9754,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8720,
            "endOffset": 9479,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 1
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 1
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 3
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 4
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 8
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 4
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 4
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 0
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14133,
            "endOffset": 14156,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14319,
            "endOffset": 14373,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14390,
            "endOffset": 14702,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14925,
            "endOffset": 14956,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 4
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 1
          },
          {
            "startOffset": 15218,
            "endOffset": 15227,
            "count": 0
          },
          {
            "startOffset": 15228,
            "endOffset": 15387,
            "count": 0
          },
          {
            "startOffset": 15467,
            "endOffset": 15500,
            "count": 0
          },
          {
            "startOffset": 15512,
            "endOffset": 15572,
            "count": 0
          },
          {
            "startOffset": 15573,
            "endOffset": 15651,
            "count": 0
          },
          {
            "startOffset": 15709,
            "endOffset": 15765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 3
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 3
          },
          {
            "startOffset": 4604,
            "endOffset": 5231,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4669,
            "endOffset": 5221,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5370,
            "endOffset": 5595,
            "count": 13
          },
          {
            "startOffset": 5416,
            "endOffset": 5441,
            "count": 5
          },
          {
            "startOffset": 5442,
            "endOffset": 5504,
            "count": 5
          },
          {
            "startOffset": 5504,
            "endOffset": 5562,
            "count": 8
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5697,
            "endOffset": 5920,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5805,
            "endOffset": 5821,
            "count": 5
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5940,
            "endOffset": 6258,
            "count": 3
          },
          {
            "startOffset": 6006,
            "endOffset": 6169,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 3
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 9
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 6
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 3
          },
          {
            "startOffset": 9900,
            "endOffset": 9963,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 9821,
            "count": 3
          },
          {
            "startOffset": 7851,
            "endOffset": 7865,
            "count": 0
          },
          {
            "startOffset": 7881,
            "endOffset": 7894,
            "count": 0
          },
          {
            "startOffset": 8441,
            "endOffset": 8448,
            "count": 1
          },
          {
            "startOffset": 8470,
            "endOffset": 9738,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8720,
            "endOffset": 9479,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 3
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 3
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 3
          },
          {
            "startOffset": 831,
            "endOffset": 838,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 841,
            "endOffset": 852,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 911,
            "endOffset": 1122,
            "count": 6
          },
          {
            "startOffset": 956,
            "endOffset": 1027,
            "count": 5
          },
          {
            "startOffset": 1027,
            "endOffset": 1114,
            "count": 1
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 49
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2881,
            "endOffset": 3630,
            "count": 3
          },
          {
            "startOffset": 2980,
            "endOffset": 2990,
            "count": 1
          },
          {
            "startOffset": 2990,
            "endOffset": 3629,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3012,
            "endOffset": 3613,
            "count": 3
          },
          {
            "startOffset": 3393,
            "endOffset": 3409,
            "count": 0
          },
          {
            "startOffset": 3411,
            "endOffset": 3577,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3449,
            "endOffset": 3565,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3803,
            "endOffset": 3912,
            "count": 2
          },
          {
            "startOffset": 3880,
            "endOffset": 3891,
            "count": 1
          },
          {
            "startOffset": 3892,
            "endOffset": 3905,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4065,
            "endOffset": 4148,
            "count": 4
          },
          {
            "startOffset": 4137,
            "endOffset": 4141,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4310,
            "endOffset": 4393,
            "count": 5
          },
          {
            "startOffset": 4372,
            "endOffset": 4376,
            "count": 4
          },
          {
            "startOffset": 4377,
            "endOffset": 4386,
            "count": 1
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 22
          },
          {
            "startOffset": 4604,
            "endOffset": 5231,
            "count": 15
          },
          {
            "startOffset": 5231,
            "endOffset": 6262,
            "count": 7
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4669,
            "endOffset": 5221,
            "count": 15
          },
          {
            "startOffset": 4734,
            "endOffset": 4851,
            "count": 1
          },
          {
            "startOffset": 4851,
            "endOffset": 5220,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5092,
            "endOffset": 5180,
            "count": 4
          },
          {
            "startOffset": 5149,
            "endOffset": 5160,
            "count": 1
          },
          {
            "startOffset": 5161,
            "endOffset": 5165,
            "count": 3
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5370,
            "endOffset": 5595,
            "count": 21
          },
          {
            "startOffset": 5416,
            "endOffset": 5441,
            "count": 7
          },
          {
            "startOffset": 5442,
            "endOffset": 5504,
            "count": 7
          },
          {
            "startOffset": 5504,
            "endOffset": 5562,
            "count": 14
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5697,
            "endOffset": 5920,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5805,
            "endOffset": 5821,
            "count": 8
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5940,
            "endOffset": 6258,
            "count": 9
          },
          {
            "startOffset": 6006,
            "endOffset": 6169,
            "count": 1
          },
          {
            "startOffset": 6169,
            "endOffset": 6257,
            "count": 8
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 7
          },
          {
            "startOffset": 6350,
            "endOffset": 6365,
            "count": 2
          },
          {
            "startOffset": 6366,
            "endOffset": 6391,
            "count": 2
          },
          {
            "startOffset": 6391,
            "endOffset": 6429,
            "count": 5
          },
          {
            "startOffset": 6429,
            "endOffset": 6470,
            "count": 1
          },
          {
            "startOffset": 6470,
            "endOffset": 6560,
            "count": 4
          },
          {
            "startOffset": 6560,
            "endOffset": 6585,
            "count": 1
          },
          {
            "startOffset": 6585,
            "endOffset": 6647,
            "count": 3
          },
          {
            "startOffset": 6621,
            "endOffset": 6647,
            "count": 1
          },
          {
            "startOffset": 6647,
            "endOffset": 6732,
            "count": 2
          },
          {
            "startOffset": 6732,
            "endOffset": 6767,
            "count": 0
          },
          {
            "startOffset": 6772,
            "endOffset": 6836,
            "count": 2
          },
          {
            "startOffset": 6801,
            "endOffset": 6836,
            "count": 0
          },
          {
            "startOffset": 6837,
            "endOffset": 6875,
            "count": 0
          },
          {
            "startOffset": 6875,
            "endOffset": 6896,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 38
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 99
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 61
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 58
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 20
          },
          {
            "startOffset": 7706,
            "endOffset": 9900,
            "count": 19
          },
          {
            "startOffset": 9900,
            "endOffset": 9963,
            "count": 1
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 9821,
            "count": 21
          },
          {
            "startOffset": 7851,
            "endOffset": 7865,
            "count": 2
          },
          {
            "startOffset": 7881,
            "endOffset": 7894,
            "count": 2
          },
          {
            "startOffset": 7894,
            "endOffset": 7971,
            "count": 19
          },
          {
            "startOffset": 7971,
            "endOffset": 9754,
            "count": 18
          },
          {
            "startOffset": 8028,
            "endOffset": 8470,
            "count": 13
          },
          {
            "startOffset": 8441,
            "endOffset": 8448,
            "count": 0
          },
          {
            "startOffset": 8470,
            "endOffset": 9738,
            "count": 5
          },
          {
            "startOffset": 8590,
            "endOffset": 8635,
            "count": 4
          },
          {
            "startOffset": 8637,
            "endOffset": 9540,
            "count": 4
          },
          {
            "startOffset": 9540,
            "endOffset": 9738,
            "count": 1
          },
          {
            "startOffset": 9754,
            "endOffset": 9820,
            "count": 16
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8720,
            "endOffset": 9479,
            "count": 4
          },
          {
            "startOffset": 8820,
            "endOffset": 8847,
            "count": 1
          },
          {
            "startOffset": 8848,
            "endOffset": 8951,
            "count": 1
          },
          {
            "startOffset": 9154,
            "endOffset": 9279,
            "count": 1
          },
          {
            "startOffset": 9279,
            "endOffset": 9416,
            "count": 3
          },
          {
            "startOffset": 9362,
            "endOffset": 9369,
            "count": 1
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 50
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 24
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 1
          },
          {
            "startOffset": 12066,
            "endOffset": 12118,
            "count": 49
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 63
          },
          {
            "startOffset": 10553,
            "endOffset": 10599,
            "count": 62
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 47
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 1
          },
          {
            "startOffset": 11041,
            "endOffset": 11174,
            "count": 0
          },
          {
            "startOffset": 11226,
            "endOffset": 11256,
            "count": 0
          },
          {
            "startOffset": 11333,
            "endOffset": 11377,
            "count": 0
          },
          {
            "startOffset": 11649,
            "endOffset": 11975,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 2
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12923,
            "endOffset": 12954,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 38
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14133,
            "endOffset": 14156,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14319,
            "endOffset": 14373,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14390,
            "endOffset": 14702,
            "count": 1
          },
          {
            "startOffset": 14523,
            "endOffset": 14590,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14925,
            "endOffset": 14956,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 38
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 11
          },
          {
            "startOffset": 15218,
            "endOffset": 15227,
            "count": 5
          },
          {
            "startOffset": 15228,
            "endOffset": 15387,
            "count": 5
          },
          {
            "startOffset": 15387,
            "endOffset": 15864,
            "count": 6
          },
          {
            "startOffset": 15467,
            "endOffset": 15500,
            "count": 0
          },
          {
            "startOffset": 15512,
            "endOffset": 15572,
            "count": 0
          },
          {
            "startOffset": 15573,
            "endOffset": 15651,
            "count": 0
          },
          {
            "startOffset": 15709,
            "endOffset": 15765,
            "count": 1
          },
          {
            "startOffset": 15765,
            "endOffset": 15853,
            "count": 5
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 10
          },
          {
            "startOffset": 16546,
            "endOffset": 16553,
            "count": 1
          },
          {
            "startOffset": 16553,
            "endOffset": 16580,
            "count": 9
          },
          {
            "startOffset": 16580,
            "endOffset": 16613,
            "count": 7
          },
          {
            "startOffset": 16614,
            "endOffset": 16662,
            "count": 2
          },
          {
            "startOffset": 16662,
            "endOffset": 16764,
            "count": 9
          },
          {
            "startOffset": 16764,
            "endOffset": 17256,
            "count": 3
          },
          {
            "startOffset": 16872,
            "endOffset": 16994,
            "count": 2
          },
          {
            "startOffset": 16994,
            "endOffset": 17248,
            "count": 1
          },
          {
            "startOffset": 17256,
            "endOffset": 17340,
            "count": 9
          },
          {
            "startOffset": 17340,
            "endOffset": 17360,
            "count": 0
          },
          {
            "startOffset": 17360,
            "endOffset": 17386,
            "count": 9
          },
          {
            "startOffset": 17386,
            "endOffset": 17427,
            "count": 2
          },
          {
            "startOffset": 17427,
            "endOffset": 17481,
            "count": 7
          },
          {
            "startOffset": 17481,
            "endOffset": 17513,
            "count": 9
          },
          {
            "startOffset": 17513,
            "endOffset": 17572,
            "count": 0
          },
          {
            "startOffset": 17572,
            "endOffset": 17609,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17173,
            "endOffset": 17196,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 10
          },
          {
            "startOffset": 486,
            "endOffset": 555,
            "count": 150
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 9
          },
          {
            "startOffset": 839,
            "endOffset": 852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 841,
            "endOffset": 852,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 911,
            "endOffset": 1122,
            "count": 45
          },
          {
            "startOffset": 956,
            "endOffset": 1027,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 20
          },
          {
            "startOffset": 1491,
            "endOffset": 1498,
            "count": 11
          },
          {
            "startOffset": 1498,
            "endOffset": 1818,
            "count": 9
          },
          {
            "startOffset": 1765,
            "endOffset": 1770,
            "count": 0
          },
          {
            "startOffset": 1818,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 18
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 2
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 5
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 3
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 20
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 10
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 30
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 30
          },
          {
            "startOffset": 10821,
            "endOffset": 11041,
            "count": 10
          },
          {
            "startOffset": 11041,
            "endOffset": 11174,
            "count": 20
          },
          {
            "startOffset": 11105,
            "endOffset": 11174,
            "count": 10
          },
          {
            "startOffset": 11226,
            "endOffset": 11256,
            "count": 10
          },
          {
            "startOffset": 11256,
            "endOffset": 11377,
            "count": 20
          },
          {
            "startOffset": 11378,
            "endOffset": 11993,
            "count": 10
          },
          {
            "startOffset": 11499,
            "endOffset": 11649,
            "count": 0
          },
          {
            "startOffset": 11764,
            "endOffset": 11806,
            "count": 0
          },
          {
            "startOffset": 11962,
            "endOffset": 11969,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 11
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 20
          },
          {
            "startOffset": 15218,
            "endOffset": 15227,
            "count": 0
          },
          {
            "startOffset": 15228,
            "endOffset": 15387,
            "count": 0
          },
          {
            "startOffset": 15467,
            "endOffset": 15500,
            "count": 10
          },
          {
            "startOffset": 15512,
            "endOffset": 15572,
            "count": 10
          },
          {
            "startOffset": 15573,
            "endOffset": 15864,
            "count": 10
          },
          {
            "startOffset": 15709,
            "endOffset": 15765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "\n// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n    window.hyperElement = factory(window.hyperHTML);\n}(function (hyperHTML) {\n\n  const manager = { }, sharedAttrs = { },  customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g, isCustomTag = /<+\\w+[-]+\\w/\n\n\n  function makeid() {\n    var text = \"\";\n    var possible = \"bcdfghjklmnpqrstvwxyz\";\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n//=====================================================\n//=========================== re-render on store change\n//=====================================================\n\n  function onNext(that,store){\n\n      const storeFn = (\"function\" == typeof store) ? store : () => store\n\n      const render = this.render\n\n       const render2 = (...data)=>{\n\n        if(undefined === store){\n          that.store = undefined;\n          render(...data)\n        } else {\n          that.store = storeFn()\n          render(that.store,...data)\n        }\n      }\n       this.render = render2;\n\n      return render2;\n  }\n\n//=====================================================\n//======================== Observer change to innerHTML\n//=====================================================\n\n  function observer(ref){\n   const that = ref.this\n    const mutationObserver = new MutationObserver((mutations)=> {\n\n      if(!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter(m => m.type === 'attributes');\n      if(attrMutations.length > 0){\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent\n\n      ref.innerHTML = this.innerHTML\n\t\t\tif(that.attrs.template){\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n        //reset the element\n        hyperHTML.bind(ref.shadow)`` // HACK, dont know why this works?\n\n        that.wrappedContent = textContent\n        this.render()\n    });\n\n    mutationObserver.observe(this, {\n        // Watch attribute changes to trigger re-renders\n        attributes: true,\n\n        // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n        childList: true,\n\n        // Set to true if mutations to target and target's descendants are to be observed.\n        subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr.map((item, index) => {\n        let itemContent = content;\n        // Replace {.} with current item (for primitives)\n        itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n        // Replace {@index} with current index\n        itemContent = itemContent.replace(/\\{@index\\}/g, index);\n        // If item is object, replace {prop} with item.prop\n        if (typeof item === 'object' && item !== null) {\n          Object.keys(item).forEach(key => {\n            itemContent = itemContent.replace(new RegExp('\\\\{' + key + '\\\\}', 'g'), item[key]);\n          });\n        }\n        return itemContent;\n      }).join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifElseRegex, (match, condition, ifContent, elseContent) => {\n      return data[condition] ? ifContent : elseContent;\n    });\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML){\n        // Check if template has advanced features\n        const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n        if (hasAdvanced) {\n          // Use advanced template processing\n          return function template(data){\n            if(\"object\" !== typeof data){\n              throw new Error(\"Templates must be passed an object. You passed \"+JSON.stringify(data))\n            }\n            // Process advanced template features\n            let result = processAdvancedTemplate(innerHTML, data);\n            // Simple variable substitution for remaining {var} patterns\n            result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n              return data[key] != null ? data[key] : '';\n            });\n            return result;\n          }\n        }\n\n        // Original simple template processing\n        const re = /(\\{[\\w]+\\})/g\n        const templateVals = innerHTML.split(re).reduce((vals,item)=>{\n\n           if(\"{\" === item[0] && \"}\" === item.slice(-1)){\n               vals.keys.push(item.slice(1,-1))\n           } else {\n               vals.markup.push(item)\n           }\n\n          return vals\n        },{markup:[],keys:[]})\n\n           templateVals.id = \":\"+templateVals.markup.join().trim()\n\n           function fragment(data,render){\n\n             const output = [templateVals.markup,...templateVals.keys.map( key => data[key] )]\n             output.raw =  { value:templateVals.markup}\n             return output\n           }\n\n           return function template(data){\n             if(\"object\" !== typeof data){\n               throw new Error(\"Templates must be passed an object to be populated with. You passed \"+JSON.stringify(data)+\" to \"+templateVals.id)\n             }\n             return hyperHTML.wire(data,templateVals.id)(...fragment(data))\n           }\n\n  } // END buildTemplate\n\n  function parceAttribute(key,value){\n    if(\"template\" === key && \"\" === value){\n      return true\n    }\n\n    if((+value)+\"\" === value.trim()){\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim()\n\n    if(\"true\" === lowerCaseValue){\n      return true\n    } else if(\"false\" === lowerCaseValue){\n      return false\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if(lowerCaseValue[0] === \"[\" && lowerCaseValue.slice(-1) === \"]\"\n    || lowerCaseValue[0] === \"{\" && lowerCaseValue.slice(-1) === \"}\"){\n      return JSON.parse(value)\n    }\n\n    return value\n  } // END parceAttribute\n\n\n\n//=====================================================\n//======================================= All the magic\n//=====================================================\n\nfunction  createdCallback(){\n\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n  const ref = manager[this.identifier] = {attrsToIgnore:{}}\n    ref.innerHTML = this.innerHTML\n    const that = ref.this = {element:this}\n     that.wrappedContent = this.textContent\n\n    observer.call(this,ref) // observer change to innerHTML\n\n  Object.getOwnPropertyNames(this.__proto__)\n        .filter(name => ! (\n          \"constructor\" === name ||\n          \"setup\"       === name ||\n          \"render\"      === name\n        ))\n        .forEach( name => {\n        \tif(/^[A-Z]/.test(name)){\n            let result;\n           const templatestrings = {};\n          \tconst wrapFragment = (data)=>{\n\n            \tif(undefined !== result && result.once)\n              return result\n\n              result = this[name](data)\n              if(!!result.template){\n                if(\"string\" === typeof result.template){\n                 /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                  if(!templatestrings[result.template]){\n                    templatestrings[result.template] = buildTemplate(result.template)\n                  }\n                  result = { any : templatestrings[result.template]( result.values || data ) }\n                } // END \"string\" === typeof result.template\n                else if(\"object\" === typeof result.template\n                && \"function\" === typeof result.template.then ){\n\n                  result = Object.assign({},result,{ any : result.template.then(args => {\n\n                      let { template, values } = args\n                      if(!template && \"string\" === typeof args){\n                        template = args;\n                        values = {};\n                      }\n\n                      if(!templatestrings[template]){\n                        templatestrings[template] = buildTemplate(template)\n                      }\n                      if(Array.isArray(values)){\n                        result = { any : values.map(templatestrings[template]), once: result.once }\n                      } else {\n                        result = { any : templatestrings[template]( values || data ), once: result.once }\n                      }\n                      return result.any;\n                    })\n                  })// END Object.assign\n\n                } // END result.template is promise ?\n                else {\n                  throw new Error(\"unknow template type:\"+typeof result.template +\" | \"+JSON.stringify(result.template))\n                }\n              } // END !!result.template\n              return result\n            } // END wrapFragment\n          \thyperHTML.define(name,wrapFragment)\n          }else{\n           that[name] = this[name].bind(that)\n          }\n           delete this[name]\n         })\n         function toString(){ return \"hyper-element: \"+this.localName }\n         Object.defineProperty(that,\"toString\",{ value: toString.bind(this), writable: false })\n                                                     // use shadow DOM, else fallback to render to element\n   ref.shadow =  this//.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n   // Restrict access to hyperHTML\n   const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n   ref.Html = function Html(...args){\n\n     if( args.slice(1).some(item => \"function\" === typeof item || (item !== null && \"object\" === typeof item))\n     && args[0].some(t=>isCustomTag.test(t))){\n\n       let inCustomTag = false;\n       let localName   = \"\"\n       const lookup    = []\n\n       args[0].forEach((item, index, items)=>{\n\n         if(isCustomTag.test(item)){\n           inCustomTag = -1 === item.substring(item.match(isCustomTag).index).indexOf(\">\")\n           localName = inCustomTag && item.substring(item.indexOf(item.match(isCustomTag))).split(\" \")[0].substr(1);\n         }// END if CustomTag start\n         else if(0<=item.indexOf(\">\")){\n           inCustomTag = false\n           localName = \"\"\n         }// END if CustomTag end\n\n         if( ! inCustomTag){\n           return\n         }\n         const val = args[index+1]\n\n           if(\"function\" === typeof val || (val !== null && \"object\" === typeof val)){\n               const attrName = item.split(\" \").pop().slice(0, -1);\n               if(\"on\" === attrName.substring(0,2)){\n                 throw new Error(`'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`)\n               }\n               // Don't intercept style - let hyperHTML handle it natively\n               if(\"style\" === attrName){\n                 return\n               }\n               const id = makeid()\n               sharedAttrs[id] = { attrName, val, localName }\n               args[index+1] = (\"function\" === typeof val ? 'fn-':'ob-')+id;\n           }// END if(\"function\" === typeof val)\n          })// END forEach\n        }// END if\n\n        return hyperHTMLbind(...args)\n   } // END ref.Html\n   ref.Html.wire = function wire(...args){return hyperHTML.wire(...args)}\n   ref.Html.lite = function lite(...args){return hyperHTML(...args)}\n\n   // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n   that.attrs = this.attachAttrs(this.attributes);\n   that.dataset = this.getDataset()\n\t\tconst render = this.render\n   this.render = (...data)=>{\n      ref.observe = false\n       setTimeout(()=>{ref.observe = true},0)\n\n       render.call(that,ref.Html,...data)\n\n       //after render check if dataset has chacked\n       Object.getOwnPropertyNames(that.dataset)\n            .filter(key => !this.dataset[key])\n            .forEach( key => {\n\n                const value = that.dataset[key]\n                this.addDataset(that.dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`))\n                that.dataset[key] = value\n            })\n   }\n\n   if(this.setup){\n     ref.teardown = this.setup.call(that,onNext.bind(this,that))\n   }\n\n   this.render()\n\n  }\n\n//=====================================================\n//==================================== Wrap the element\n//=====================================================\n\n  class hyperElement extends HTMLElement{\n\n//++++++++++++++++++++++++++++++++ get element content\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow(){\n      return manager[this.identifier].shadow.innerHTML\n    }\n\n//++++++++++++++++++++++++++++++++++++++++++++++ Setup\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback(){\n      createdCallback.call(this)\n    }\n\n//+++++++++++++++++++++++++++++++++++++++ attach Attrs\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key){\n\n        const camel_key = dash_key.replace(/-([a-z])/g, g => g[1].toUpperCase())\n\n        Object.defineProperty(dataset, camel_key, {\n          enumerable:true, // can be selected\n          configurable: true, // can be delete\n          get: ()=> parceAttribute(camel_key,this.dataset[camel_key]),\n          set: (value)=> {\n              manager[this.identifier].attrsToIgnore[\"data-\"+dash_key] = true\n              if(\"string\" === typeof value){\n                  this.dataset[camel_key] = value\n              } else {\n                  this.dataset[camel_key] = JSON.stringify(value)\n              }// END else\n          } // END set\n\n        }) // END defineProperty\n    } // END addDataset\n\n    getDataset(){\n      const dataset = {}\n      Object.keys(this.dataset)\n            .forEach(key => this.addDataset(dataset, key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`) ))// END forEach\n        return dataset\n    } // END getDataset\n\n    attachAttrs(attributes){\n\n     \tconst accumulator = { };\n\n      for (let i = 0; i < attributes.length; i++) {\n         const { value, name } = attributes[i];\n\n         if(\"template\" === name && !value){\n\n           const ref = manager[this.identifier]\n           ref.Html.template = buildTemplate(ref.innerHTML)\n           accumulator[name] = true;\n\n         } else if ((\"fn-\" === value.substr(0,3) || \"ob-\" === value.substr(0,3))\n         && !!sharedAttrs[value.substr(3)]\n           && sharedAttrs[value.substr(3)].localName === this.localName){\n             accumulator[name] = sharedAttrs[value.substr(3)].val\n         } else {\n         \t   if((+value)+\"\" === (value+\"\").trim()){\n           \t\t\taccumulator[name] = +value\n            } else{\n           \t\t\taccumulator[name] = value//parceAttribute(name,value)\n            }\n         }\n     }\n     return accumulator;\n    }\n/*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n//+++++++++++++++++++++++++++++++++++ element teardown\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\n/*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name,oldVal,newVal){\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier]\n      if(!ref) return;\n\n      if(newVal !== null && (+newVal)+\"\" === newVal.trim()){\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this\n      if(0 <= name.indexOf(\"data-\")){\n        // we have data\n        const dataSetName = name.slice(\"data-\".length)\n        if(null === oldVal){\n        //if(undefined === that.dataset[dataSetName]){\n             this.addDataset(that.dataset, dataSetName)\n        } else if(null === newVal){\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, g => g[1].toUpperCase())\n          delete that.dataset[camel_key]\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n    if( newVal === that.attrs[name]) {\n      return\n    }\n      if(null === newVal){\n        delete that.attrs[name]\n      }\n      else{\n        that.attrs[name] = newVal\n      }\n      if(!!attrsToIgnore[name]){\n        delete attrsToIgnore[name]\n        return\n      } else{\n        this.render();\n      } // END else\n\n    } // END attributeChangedCallback\n\n    disconnectedCallback(){\n      const ref = manager[this.identifier]\n      ref.teardown && ref.teardown()\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n//=====================================================\n//================================================ Done\n//=====================================================\n\n  return hyperElement;\n\n}));\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18094,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 144,
            "endOffset": 219,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 220,
            "endOffset": 18090,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 363,
            "endOffset": 577,
            "count": 1
          },
          {
            "startOffset": 486,
            "endOffset": 555,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 750,
            "endOffset": 1179,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1352,
            "endOffset": 2604,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1451,
            "endOffset": 2200,
            "count": 4
          },
          {
            "startOffset": 1498,
            "endOffset": 2199,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1582,
            "endOffset": 1610,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2660,
            "endOffset": 4419,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 6263,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6288,
            "endOffset": 6897,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7092,
            "endOffset": 13131,
            "count": 4
          },
          {
            "startOffset": 13037,
            "endOffset": 13108,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7518,
            "endOffset": 7644,
            "count": 9
          },
          {
            "startOffset": 7563,
            "endOffset": 7598,
            "count": 5
          },
          {
            "startOffset": 7599,
            "endOffset": 7634,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7664,
            "endOffset": 10003,
            "count": 1
          },
          {
            "startOffset": 7706,
            "endOffset": 9900,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 9821,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10014,
            "endOffset": 10076,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10465,
            "endOffset": 12119,
            "count": 4
          },
          {
            "startOffset": 10606,
            "endOffset": 10645,
            "count": 2
          },
          {
            "startOffset": 10646,
            "endOffset": 12066,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10518,
            "endOffset": 10599,
            "count": 3
          },
          {
            "startOffset": 10553,
            "endOffset": 10599,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10622,
            "endOffset": 10644,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10761,
            "endOffset": 12041,
            "count": 5
          },
          {
            "startOffset": 10821,
            "endOffset": 11041,
            "count": 2
          },
          {
            "startOffset": 11041,
            "endOffset": 11174,
            "count": 3
          },
          {
            "startOffset": 11105,
            "endOffset": 11174,
            "count": 2
          },
          {
            "startOffset": 11226,
            "endOffset": 11256,
            "count": 2
          },
          {
            "startOffset": 11256,
            "endOffset": 11333,
            "count": 3
          },
          {
            "startOffset": 11333,
            "endOffset": 11377,
            "count": 2
          },
          {
            "startOffset": 11378,
            "endOffset": 11993,
            "count": 3
          },
          {
            "startOffset": 11499,
            "endOffset": 11649,
            "count": 0
          },
          {
            "startOffset": 11764,
            "endOffset": 11806,
            "count": 2
          },
          {
            "startOffset": 11806,
            "endOffset": 11969,
            "count": 1
          },
          {
            "startOffset": 11969,
            "endOffset": 11975,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12155,
            "endOffset": 12209,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12229,
            "endOffset": 12278,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12498,
            "endOffset": 13018,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12555,
            "endOffset": 12579,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12746,
            "endOffset": 12771,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12795,
            "endOffset": 13012,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13460,
            "endOffset": 13539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13869,
            "endOffset": 13928,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14045,
            "endOffset": 14753,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14777,
            "endOffset": 15003,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14959,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15027,
            "endOffset": 15902,
            "count": 4
          },
          {
            "startOffset": 15135,
            "endOffset": 15871,
            "count": 3
          },
          {
            "startOffset": 15218,
            "endOffset": 15227,
            "count": 0
          },
          {
            "startOffset": 15228,
            "endOffset": 15387,
            "count": 0
          },
          {
            "startOffset": 15426,
            "endOffset": 15456,
            "count": 2
          },
          {
            "startOffset": 15467,
            "endOffset": 15500,
            "count": 1
          },
          {
            "startOffset": 15512,
            "endOffset": 15572,
            "count": 1
          },
          {
            "startOffset": 15573,
            "endOffset": 15651,
            "count": 1
          },
          {
            "startOffset": 15651,
            "endOffset": 15864,
            "count": 2
          },
          {
            "startOffset": 15709,
            "endOffset": 15765,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 16279,
            "endOffset": 17628,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17666,
            "endOffset": 17862,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 1
          },
          {
            "startOffset": 492,
            "endOffset": 561,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 4
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 4
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 9
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 5
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 1
          },
          {
            "startOffset": 7848,
            "endOffset": 10345,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 4
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 1
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 4
          },
          {
            "startOffset": 11035,
            "endOffset": 11095,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 2
          },
          {
            "startOffset": 11347,
            "endOffset": 11808,
            "count": 1
          },
          {
            "startOffset": 11862,
            "endOffset": 11989,
            "count": 1
          },
          {
            "startOffset": 11989,
            "endOffset": 12045,
            "count": 0
          },
          {
            "startOffset": 12058,
            "endOffset": 12686,
            "count": 1
          },
          {
            "startOffset": 12176,
            "endOffset": 12353,
            "count": 0
          },
          {
            "startOffset": 12464,
            "endOffset": 12501,
            "count": 0
          },
          {
            "startOffset": 12660,
            "endOffset": 12667,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 4
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 2
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16270,
            "endOffset": 16301,
            "count": 1
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 1
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 1
          },
          {
            "startOffset": 16428,
            "endOffset": 16712,
            "count": 1
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 7
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2878,
            "endOffset": 3721,
            "count": 2
          },
          {
            "startOffset": 2977,
            "endOffset": 2987,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3018,
            "endOffset": 3695,
            "count": 5
          },
          {
            "startOffset": 3413,
            "endOffset": 3429,
            "count": 2
          },
          {
            "startOffset": 3431,
            "endOffset": 3655,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3471,
            "endOffset": 3641,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3907,
            "endOffset": 4020,
            "count": 1
          },
          {
            "startOffset": 3986,
            "endOffset": 3997,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4178,
            "endOffset": 4261,
            "count": 2
          },
          {
            "startOffset": 4240,
            "endOffset": 4249,
            "count": 1
          },
          {
            "startOffset": 4250,
            "endOffset": 4254,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 4506,
            "count": 1
          },
          {
            "startOffset": 4485,
            "endOffset": 4489,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 7
          },
          {
            "startOffset": 4706,
            "endOffset": 5322,
            "count": 6
          },
          {
            "startOffset": 5322,
            "endOffset": 6370,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4763,
            "endOffset": 5315,
            "count": 6
          },
          {
            "startOffset": 4827,
            "endOffset": 4977,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5202,
            "endOffset": 5282,
            "count": 1
          },
          {
            "startOffset": 5267,
            "endOffset": 5271,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5457,
            "endOffset": 5667,
            "count": 3
          },
          {
            "startOffset": 5503,
            "endOffset": 5528,
            "count": 1
          },
          {
            "startOffset": 5530,
            "endOffset": 5586,
            "count": 1
          },
          {
            "startOffset": 5586,
            "endOffset": 5637,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5776,
            "endOffset": 6002,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5895,
            "endOffset": 5913,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6015,
            "endOffset": 6366,
            "count": 1
          },
          {
            "startOffset": 6077,
            "endOffset": 6289,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 7
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 14
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 7
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 7
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 1
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 7
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 7
          },
          {
            "startOffset": 16219,
            "endOffset": 16712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 3
          },
          {
            "startOffset": 6461,
            "endOffset": 6476,
            "count": 0
          },
          {
            "startOffset": 6478,
            "endOffset": 6504,
            "count": 0
          },
          {
            "startOffset": 6544,
            "endOffset": 6585,
            "count": 0
          },
          {
            "startOffset": 6678,
            "endOffset": 6704,
            "count": 0
          },
          {
            "startOffset": 6742,
            "endOffset": 6769,
            "count": 0
          },
          {
            "startOffset": 6900,
            "endOffset": 6972,
            "count": 0
          },
          {
            "startOffset": 7018,
            "endOffset": 7040,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 3
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 6
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 3
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 3
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13688,
            "endOffset": 13719,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14945,
            "endOffset": 14978,
            "count": 2
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15142,
            "endOffset": 15198,
            "count": 3
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15213,
            "endOffset": 15504,
            "count": 3
          },
          {
            "startOffset": 15344,
            "endOffset": 15402,
            "count": 1
          },
          {
            "startOffset": 15402,
            "endOffset": 15482,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15746,
            "endOffset": 15777,
            "count": 2
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 3
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 2
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 0
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 0
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 0
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 4
          },
          {
            "startOffset": 492,
            "endOffset": 561,
            "count": 60
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 6
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 6
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 13
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 7
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 1
          },
          {
            "startOffset": 7848,
            "endOffset": 10345,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 6
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 3
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 6
          },
          {
            "startOffset": 11035,
            "endOffset": 11095,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 7
          },
          {
            "startOffset": 11347,
            "endOffset": 11664,
            "count": 3
          },
          {
            "startOffset": 11664,
            "endOffset": 11808,
            "count": 4
          },
          {
            "startOffset": 11734,
            "endOffset": 11808,
            "count": 3
          },
          {
            "startOffset": 11862,
            "endOffset": 11895,
            "count": 3
          },
          {
            "startOffset": 11895,
            "endOffset": 11989,
            "count": 4
          },
          {
            "startOffset": 11989,
            "endOffset": 12045,
            "count": 3
          },
          {
            "startOffset": 12058,
            "endOffset": 12686,
            "count": 4
          },
          {
            "startOffset": 12176,
            "endOffset": 12353,
            "count": 0
          },
          {
            "startOffset": 12464,
            "endOffset": 12501,
            "count": 0
          },
          {
            "startOffset": 12652,
            "endOffset": 12659,
            "count": 1
          },
          {
            "startOffset": 12660,
            "endOffset": 12667,
            "count": 3
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 6
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 6
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 5
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16270,
            "endOffset": 16301,
            "count": 4
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 4
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 4
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 4
          },
          {
            "startOffset": 16503,
            "endOffset": 16712,
            "count": 1
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 2
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 7
          },
          {
            "startOffset": 6461,
            "endOffset": 6476,
            "count": 0
          },
          {
            "startOffset": 6478,
            "endOffset": 6504,
            "count": 0
          },
          {
            "startOffset": 6544,
            "endOffset": 6585,
            "count": 0
          },
          {
            "startOffset": 6678,
            "endOffset": 6704,
            "count": 0
          },
          {
            "startOffset": 6742,
            "endOffset": 6769,
            "count": 0
          },
          {
            "startOffset": 6900,
            "endOffset": 6972,
            "count": 0
          },
          {
            "startOffset": 7018,
            "endOffset": 7040,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 2
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 4
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 2
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 2
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14945,
            "endOffset": 14978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15142,
            "endOffset": 15198,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15213,
            "endOffset": 15504,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15746,
            "endOffset": 15777,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 2
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 0
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 0
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 0
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 2
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 1
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 1
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 1
          },
          {
            "startOffset": 848,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 850,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 917,
            "endOffset": 1119,
            "count": 2
          },
          {
            "startOffset": 963,
            "endOffset": 1029,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 3
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 2
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 2
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 2
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 1
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 1
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 1
          },
          {
            "startOffset": 4706,
            "endOffset": 5322,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4763,
            "endOffset": 5315,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5457,
            "endOffset": 5667,
            "count": 3
          },
          {
            "startOffset": 5503,
            "endOffset": 5528,
            "count": 1
          },
          {
            "startOffset": 5530,
            "endOffset": 5586,
            "count": 1
          },
          {
            "startOffset": 5586,
            "endOffset": 5637,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5776,
            "endOffset": 6002,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5895,
            "endOffset": 5913,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6015,
            "endOffset": 6366,
            "count": 1
          },
          {
            "startOffset": 6077,
            "endOffset": 6289,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 2
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 1
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 1
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 16219,
            "endOffset": 16712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 2
          },
          {
            "startOffset": 840,
            "endOffset": 847,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 850,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 917,
            "endOffset": 1119,
            "count": 5
          },
          {
            "startOffset": 1029,
            "endOffset": 1113,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 6
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 4
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 5
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 2
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1494,
            "endOffset": 1501,
            "count": 2
          },
          {
            "startOffset": 1501,
            "endOffset": 1654,
            "count": 1
          },
          {
            "startOffset": 1654,
            "endOffset": 1825,
            "count": 0
          },
          {
            "startOffset": 1825,
            "endOffset": 1971,
            "count": 1
          },
          {
            "startOffset": 1971,
            "endOffset": 2042,
            "count": 0
          },
          {
            "startOffset": 2042,
            "endOffset": 2208,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 1
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 2
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 1
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 2
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 4
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 8
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 4
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 4
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14945,
            "endOffset": 14978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15142,
            "endOffset": 15198,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15213,
            "endOffset": 15504,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15746,
            "endOffset": 15777,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 4
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 1
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 0
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 0
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 0
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 3
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 2
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 1
          },
          {
            "startOffset": 10345,
            "endOffset": 10408,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 1
          },
          {
            "startOffset": 7990,
            "endOffset": 8004,
            "count": 0
          },
          {
            "startOffset": 8006,
            "endOffset": 8020,
            "count": 0
          },
          {
            "startOffset": 8096,
            "endOffset": 10202,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8957,
            "endOffset": 9835,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 1
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 3
          },
          {
            "startOffset": 4706,
            "endOffset": 5322,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4763,
            "endOffset": 5315,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5457,
            "endOffset": 5667,
            "count": 13
          },
          {
            "startOffset": 5503,
            "endOffset": 5528,
            "count": 5
          },
          {
            "startOffset": 5530,
            "endOffset": 5586,
            "count": 5
          },
          {
            "startOffset": 5586,
            "endOffset": 5637,
            "count": 8
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5776,
            "endOffset": 6002,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5895,
            "endOffset": 5913,
            "count": 5
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6015,
            "endOffset": 6366,
            "count": 3
          },
          {
            "startOffset": 6077,
            "endOffset": 6289,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 3
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 9
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 6
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 3
          },
          {
            "startOffset": 10345,
            "endOffset": 10408,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 3
          },
          {
            "startOffset": 7990,
            "endOffset": 8004,
            "count": 0
          },
          {
            "startOffset": 8006,
            "endOffset": 8020,
            "count": 0
          },
          {
            "startOffset": 8616,
            "endOffset": 8623,
            "count": 1
          },
          {
            "startOffset": 8660,
            "endOffset": 10188,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8957,
            "endOffset": 9835,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 3
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 3
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 3
          },
          {
            "startOffset": 840,
            "endOffset": 847,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 850,
            "endOffset": 861,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 917,
            "endOffset": 1119,
            "count": 6
          },
          {
            "startOffset": 963,
            "endOffset": 1029,
            "count": 5
          },
          {
            "startOffset": 1029,
            "endOffset": 1113,
            "count": 1
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 49
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2878,
            "endOffset": 3721,
            "count": 3
          },
          {
            "startOffset": 2977,
            "endOffset": 2987,
            "count": 1
          },
          {
            "startOffset": 2987,
            "endOffset": 3720,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3018,
            "endOffset": 3695,
            "count": 3
          },
          {
            "startOffset": 3413,
            "endOffset": 3429,
            "count": 0
          },
          {
            "startOffset": 3431,
            "endOffset": 3655,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3471,
            "endOffset": 3641,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3907,
            "endOffset": 4020,
            "count": 2
          },
          {
            "startOffset": 3986,
            "endOffset": 3997,
            "count": 1
          },
          {
            "startOffset": 3998,
            "endOffset": 4011,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4178,
            "endOffset": 4261,
            "count": 4
          },
          {
            "startOffset": 4250,
            "endOffset": 4254,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 4506,
            "count": 5
          },
          {
            "startOffset": 4485,
            "endOffset": 4489,
            "count": 4
          },
          {
            "startOffset": 4490,
            "endOffset": 4499,
            "count": 1
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 22
          },
          {
            "startOffset": 4706,
            "endOffset": 5322,
            "count": 15
          },
          {
            "startOffset": 5322,
            "endOffset": 6370,
            "count": 7
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4763,
            "endOffset": 5315,
            "count": 15
          },
          {
            "startOffset": 4827,
            "endOffset": 4977,
            "count": 1
          },
          {
            "startOffset": 4977,
            "endOffset": 5314,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5202,
            "endOffset": 5282,
            "count": 4
          },
          {
            "startOffset": 5255,
            "endOffset": 5266,
            "count": 1
          },
          {
            "startOffset": 5267,
            "endOffset": 5271,
            "count": 3
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5457,
            "endOffset": 5667,
            "count": 21
          },
          {
            "startOffset": 5503,
            "endOffset": 5528,
            "count": 7
          },
          {
            "startOffset": 5530,
            "endOffset": 5586,
            "count": 7
          },
          {
            "startOffset": 5586,
            "endOffset": 5637,
            "count": 14
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5776,
            "endOffset": 6002,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5895,
            "endOffset": 5913,
            "count": 8
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6015,
            "endOffset": 6366,
            "count": 9
          },
          {
            "startOffset": 6077,
            "endOffset": 6289,
            "count": 1
          },
          {
            "startOffset": 6289,
            "endOffset": 6365,
            "count": 8
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 7
          },
          {
            "startOffset": 6461,
            "endOffset": 6476,
            "count": 2
          },
          {
            "startOffset": 6478,
            "endOffset": 6504,
            "count": 2
          },
          {
            "startOffset": 6504,
            "endOffset": 6544,
            "count": 5
          },
          {
            "startOffset": 6544,
            "endOffset": 6585,
            "count": 1
          },
          {
            "startOffset": 6585,
            "endOffset": 6678,
            "count": 4
          },
          {
            "startOffset": 6678,
            "endOffset": 6704,
            "count": 1
          },
          {
            "startOffset": 6704,
            "endOffset": 6769,
            "count": 3
          },
          {
            "startOffset": 6742,
            "endOffset": 6769,
            "count": 1
          },
          {
            "startOffset": 6769,
            "endOffset": 6863,
            "count": 2
          },
          {
            "startOffset": 6863,
            "endOffset": 6898,
            "count": 0
          },
          {
            "startOffset": 6900,
            "endOffset": 6972,
            "count": 2
          },
          {
            "startOffset": 6936,
            "endOffset": 6971,
            "count": 0
          },
          {
            "startOffset": 6979,
            "endOffset": 7018,
            "count": 0
          },
          {
            "startOffset": 7018,
            "endOffset": 7040,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 38
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 99
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 61
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 58
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 20
          },
          {
            "startOffset": 7848,
            "endOffset": 10345,
            "count": 19
          },
          {
            "startOffset": 10345,
            "endOffset": 10408,
            "count": 1
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 21
          },
          {
            "startOffset": 7990,
            "endOffset": 8004,
            "count": 2
          },
          {
            "startOffset": 8006,
            "endOffset": 8020,
            "count": 2
          },
          {
            "startOffset": 8020,
            "endOffset": 8096,
            "count": 19
          },
          {
            "startOffset": 8096,
            "endOffset": 10202,
            "count": 18
          },
          {
            "startOffset": 8153,
            "endOffset": 8660,
            "count": 13
          },
          {
            "startOffset": 8616,
            "endOffset": 8623,
            "count": 0
          },
          {
            "startOffset": 8660,
            "endOffset": 10188,
            "count": 5
          },
          {
            "startOffset": 8780,
            "endOffset": 8841,
            "count": 4
          },
          {
            "startOffset": 8858,
            "endOffset": 9894,
            "count": 4
          },
          {
            "startOffset": 9894,
            "endOffset": 10188,
            "count": 1
          },
          {
            "startOffset": 10202,
            "endOffset": 10265,
            "count": 16
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8957,
            "endOffset": 9835,
            "count": 4
          },
          {
            "startOffset": 9056,
            "endOffset": 9083,
            "count": 1
          },
          {
            "startOffset": 9085,
            "endOffset": 9182,
            "count": 1
          },
          {
            "startOffset": 9382,
            "endOffset": 9574,
            "count": 1
          },
          {
            "startOffset": 9574,
            "endOffset": 9776,
            "count": 3
          },
          {
            "startOffset": 9677,
            "endOffset": 9684,
            "count": 1
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 50
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 24
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 1
          },
          {
            "startOffset": 12758,
            "endOffset": 12811,
            "count": 49
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 63
          },
          {
            "startOffset": 11035,
            "endOffset": 11095,
            "count": 62
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 47
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 1
          },
          {
            "startOffset": 11664,
            "endOffset": 11808,
            "count": 0
          },
          {
            "startOffset": 11862,
            "endOffset": 11895,
            "count": 0
          },
          {
            "startOffset": 11989,
            "endOffset": 12045,
            "count": 0
          },
          {
            "startOffset": 12353,
            "endOffset": 12659,
            "count": 0
          },
          {
            "startOffset": 12660,
            "endOffset": 12667,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 2
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13688,
            "endOffset": 13719,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 38
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14945,
            "endOffset": 14978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15142,
            "endOffset": 15198,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15213,
            "endOffset": 15504,
            "count": 1
          },
          {
            "startOffset": 15344,
            "endOffset": 15402,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15746,
            "endOffset": 15777,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 38
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 11
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 5
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 5
          },
          {
            "startOffset": 16219,
            "endOffset": 16712,
            "count": 6
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 0
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 0
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 0
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 1
          },
          {
            "startOffset": 16615,
            "endOffset": 16702,
            "count": 5
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 10
          },
          {
            "startOffset": 17417,
            "endOffset": 17424,
            "count": 1
          },
          {
            "startOffset": 17424,
            "endOffset": 17452,
            "count": 9
          },
          {
            "startOffset": 17452,
            "endOffset": 17485,
            "count": 7
          },
          {
            "startOffset": 17487,
            "endOffset": 17535,
            "count": 2
          },
          {
            "startOffset": 17535,
            "endOffset": 17640,
            "count": 9
          },
          {
            "startOffset": 17640,
            "endOffset": 18164,
            "count": 3
          },
          {
            "startOffset": 17751,
            "endOffset": 17873,
            "count": 2
          },
          {
            "startOffset": 17873,
            "endOffset": 18156,
            "count": 1
          },
          {
            "startOffset": 18164,
            "endOffset": 18250,
            "count": 9
          },
          {
            "startOffset": 18250,
            "endOffset": 18275,
            "count": 0
          },
          {
            "startOffset": 18275,
            "endOffset": 18303,
            "count": 9
          },
          {
            "startOffset": 18303,
            "endOffset": 18345,
            "count": 2
          },
          {
            "startOffset": 18345,
            "endOffset": 18395,
            "count": 7
          },
          {
            "startOffset": 18395,
            "endOffset": 18429,
            "count": 9
          },
          {
            "startOffset": 18429,
            "endOffset": 18490,
            "count": 0
          },
          {
            "startOffset": 18490,
            "endOffset": 18528,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18054,
            "endOffset": 18091,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 10
          },
          {
            "startOffset": 492,
            "endOffset": 561,
            "count": 150
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 9
          },
          {
            "startOffset": 848,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 850,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 917,
            "endOffset": 1119,
            "count": 45
          },
          {
            "startOffset": 963,
            "endOffset": 1029,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 20
          },
          {
            "startOffset": 1494,
            "endOffset": 1501,
            "count": 11
          },
          {
            "startOffset": 1501,
            "endOffset": 1825,
            "count": 9
          },
          {
            "startOffset": 1772,
            "endOffset": 1777,
            "count": 0
          },
          {
            "startOffset": 1825,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 18
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 2
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 5
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 3
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 20
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 10
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 30
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 30
          },
          {
            "startOffset": 11347,
            "endOffset": 11664,
            "count": 10
          },
          {
            "startOffset": 11664,
            "endOffset": 11808,
            "count": 20
          },
          {
            "startOffset": 11734,
            "endOffset": 11808,
            "count": 10
          },
          {
            "startOffset": 11862,
            "endOffset": 11895,
            "count": 10
          },
          {
            "startOffset": 11895,
            "endOffset": 12045,
            "count": 20
          },
          {
            "startOffset": 12058,
            "endOffset": 12686,
            "count": 10
          },
          {
            "startOffset": 12176,
            "endOffset": 12353,
            "count": 0
          },
          {
            "startOffset": 12464,
            "endOffset": 12501,
            "count": 0
          },
          {
            "startOffset": 12652,
            "endOffset": 12659,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 11
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 20
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 10
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 10
          },
          {
            "startOffset": 16428,
            "endOffset": 16712,
            "count": 10
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 1
          },
          {
            "startOffset": 492,
            "endOffset": 561,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 4
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 4
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 9
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 5
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 1
          },
          {
            "startOffset": 7848,
            "endOffset": 10345,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 4
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 2
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 3
          },
          {
            "startOffset": 11035,
            "endOffset": 11095,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 5
          },
          {
            "startOffset": 11347,
            "endOffset": 11664,
            "count": 2
          },
          {
            "startOffset": 11664,
            "endOffset": 11808,
            "count": 3
          },
          {
            "startOffset": 11734,
            "endOffset": 11808,
            "count": 2
          },
          {
            "startOffset": 11862,
            "endOffset": 11895,
            "count": 2
          },
          {
            "startOffset": 11895,
            "endOffset": 11989,
            "count": 3
          },
          {
            "startOffset": 11989,
            "endOffset": 12045,
            "count": 2
          },
          {
            "startOffset": 12058,
            "endOffset": 12686,
            "count": 3
          },
          {
            "startOffset": 12176,
            "endOffset": 12353,
            "count": 0
          },
          {
            "startOffset": 12464,
            "endOffset": 12501,
            "count": 2
          },
          {
            "startOffset": 12501,
            "endOffset": 12659,
            "count": 1
          },
          {
            "startOffset": 12660,
            "endOffset": 12667,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 4
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 3
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16270,
            "endOffset": 16301,
            "count": 2
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 1
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 1
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 1
          },
          {
            "startOffset": 16503,
            "endOffset": 16712,
            "count": 2
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 3
          },
          {
            "startOffset": 6461,
            "endOffset": 6476,
            "count": 0
          },
          {
            "startOffset": 6478,
            "endOffset": 6504,
            "count": 0
          },
          {
            "startOffset": 6544,
            "endOffset": 6585,
            "count": 0
          },
          {
            "startOffset": 6678,
            "endOffset": 6704,
            "count": 0
          },
          {
            "startOffset": 6742,
            "endOffset": 6769,
            "count": 0
          },
          {
            "startOffset": 6900,
            "endOffset": 6972,
            "count": 0
          },
          {
            "startOffset": 7018,
            "endOffset": 7040,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 3
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 6
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 3
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 3
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13688,
            "endOffset": 13719,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14945,
            "endOffset": 14978,
            "count": 2
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15142,
            "endOffset": 15198,
            "count": 3
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15213,
            "endOffset": 15504,
            "count": 3
          },
          {
            "startOffset": 15344,
            "endOffset": 15402,
            "count": 1
          },
          {
            "startOffset": 15402,
            "endOffset": 15482,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15746,
            "endOffset": 15777,
            "count": 2
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 3
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 2
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 0
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 0
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 0
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 7
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2878,
            "endOffset": 3721,
            "count": 2
          },
          {
            "startOffset": 2977,
            "endOffset": 2987,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3018,
            "endOffset": 3695,
            "count": 5
          },
          {
            "startOffset": 3413,
            "endOffset": 3429,
            "count": 2
          },
          {
            "startOffset": 3431,
            "endOffset": 3655,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3471,
            "endOffset": 3641,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3907,
            "endOffset": 4020,
            "count": 1
          },
          {
            "startOffset": 3986,
            "endOffset": 3997,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4178,
            "endOffset": 4261,
            "count": 2
          },
          {
            "startOffset": 4240,
            "endOffset": 4249,
            "count": 1
          },
          {
            "startOffset": 4250,
            "endOffset": 4254,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 4506,
            "count": 1
          },
          {
            "startOffset": 4485,
            "endOffset": 4489,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 7
          },
          {
            "startOffset": 4706,
            "endOffset": 5322,
            "count": 6
          },
          {
            "startOffset": 5322,
            "endOffset": 6370,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4763,
            "endOffset": 5315,
            "count": 6
          },
          {
            "startOffset": 4827,
            "endOffset": 4977,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5202,
            "endOffset": 5282,
            "count": 1
          },
          {
            "startOffset": 5267,
            "endOffset": 5271,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5457,
            "endOffset": 5667,
            "count": 3
          },
          {
            "startOffset": 5503,
            "endOffset": 5528,
            "count": 1
          },
          {
            "startOffset": 5530,
            "endOffset": 5586,
            "count": 1
          },
          {
            "startOffset": 5586,
            "endOffset": 5637,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5776,
            "endOffset": 6002,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5895,
            "endOffset": 5913,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6015,
            "endOffset": 6366,
            "count": 1
          },
          {
            "startOffset": 6077,
            "endOffset": 6289,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 7
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 14
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 7
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 7
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 1
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 7
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 7
          },
          {
            "startOffset": 16219,
            "endOffset": 16712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 4
          },
          {
            "startOffset": 492,
            "endOffset": 561,
            "count": 60
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 6
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 6
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 13
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 7
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 1
          },
          {
            "startOffset": 7848,
            "endOffset": 10345,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 6
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 3
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 6
          },
          {
            "startOffset": 11035,
            "endOffset": 11095,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 7
          },
          {
            "startOffset": 11347,
            "endOffset": 11664,
            "count": 3
          },
          {
            "startOffset": 11664,
            "endOffset": 11808,
            "count": 4
          },
          {
            "startOffset": 11734,
            "endOffset": 11808,
            "count": 3
          },
          {
            "startOffset": 11862,
            "endOffset": 11895,
            "count": 3
          },
          {
            "startOffset": 11895,
            "endOffset": 11989,
            "count": 4
          },
          {
            "startOffset": 11989,
            "endOffset": 12045,
            "count": 3
          },
          {
            "startOffset": 12058,
            "endOffset": 12686,
            "count": 4
          },
          {
            "startOffset": 12176,
            "endOffset": 12353,
            "count": 0
          },
          {
            "startOffset": 12464,
            "endOffset": 12501,
            "count": 0
          },
          {
            "startOffset": 12652,
            "endOffset": 12659,
            "count": 1
          },
          {
            "startOffset": 12660,
            "endOffset": 12667,
            "count": 3
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 6
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 6
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 5
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16270,
            "endOffset": 16301,
            "count": 4
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 4
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 4
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 4
          },
          {
            "startOffset": 16503,
            "endOffset": 16712,
            "count": 1
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 2
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 7
          },
          {
            "startOffset": 6461,
            "endOffset": 6476,
            "count": 0
          },
          {
            "startOffset": 6478,
            "endOffset": 6504,
            "count": 0
          },
          {
            "startOffset": 6544,
            "endOffset": 6585,
            "count": 0
          },
          {
            "startOffset": 6678,
            "endOffset": 6704,
            "count": 0
          },
          {
            "startOffset": 6742,
            "endOffset": 6769,
            "count": 0
          },
          {
            "startOffset": 6900,
            "endOffset": 6972,
            "count": 0
          },
          {
            "startOffset": 7018,
            "endOffset": 7040,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 2
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 4
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 2
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 2
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14945,
            "endOffset": 14978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15142,
            "endOffset": 15198,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15213,
            "endOffset": 15504,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15746,
            "endOffset": 15777,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 2
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 0
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 0
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 0
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 1
          },
          {
            "startOffset": 848,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 850,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 917,
            "endOffset": 1119,
            "count": 2
          },
          {
            "startOffset": 963,
            "endOffset": 1029,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 3
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 2
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 2
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 2
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 1
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 1
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 1
          },
          {
            "startOffset": 4706,
            "endOffset": 5322,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4763,
            "endOffset": 5315,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5457,
            "endOffset": 5667,
            "count": 3
          },
          {
            "startOffset": 5503,
            "endOffset": 5528,
            "count": 1
          },
          {
            "startOffset": 5530,
            "endOffset": 5586,
            "count": 1
          },
          {
            "startOffset": 5586,
            "endOffset": 5637,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5776,
            "endOffset": 6002,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5895,
            "endOffset": 5913,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6015,
            "endOffset": 6366,
            "count": 1
          },
          {
            "startOffset": 6077,
            "endOffset": 6289,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 2
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 1
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 1
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 16219,
            "endOffset": 16712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 2
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 1
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 1
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 2
          },
          {
            "startOffset": 840,
            "endOffset": 847,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 850,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 917,
            "endOffset": 1119,
            "count": 5
          },
          {
            "startOffset": 1029,
            "endOffset": 1113,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 6
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 4
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 5
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 2
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1494,
            "endOffset": 1501,
            "count": 2
          },
          {
            "startOffset": 1501,
            "endOffset": 1654,
            "count": 1
          },
          {
            "startOffset": 1654,
            "endOffset": 1825,
            "count": 0
          },
          {
            "startOffset": 1825,
            "endOffset": 1971,
            "count": 1
          },
          {
            "startOffset": 1971,
            "endOffset": 2042,
            "count": 0
          },
          {
            "startOffset": 2042,
            "endOffset": 2208,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 1
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 2
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 1
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 2
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 1
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 1
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 3
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 2
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 1
          },
          {
            "startOffset": 10345,
            "endOffset": 10408,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 1
          },
          {
            "startOffset": 7990,
            "endOffset": 8004,
            "count": 0
          },
          {
            "startOffset": 8006,
            "endOffset": 8020,
            "count": 0
          },
          {
            "startOffset": 8096,
            "endOffset": 10202,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8957,
            "endOffset": 9835,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 1
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 1
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 4
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 8
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 4
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 4
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 0
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14945,
            "endOffset": 14978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15142,
            "endOffset": 15198,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15213,
            "endOffset": 15504,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15746,
            "endOffset": 15777,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 4
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 1
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 0
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 0
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 0
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 3
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 3
          },
          {
            "startOffset": 4706,
            "endOffset": 5322,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4763,
            "endOffset": 5315,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5457,
            "endOffset": 5667,
            "count": 13
          },
          {
            "startOffset": 5503,
            "endOffset": 5528,
            "count": 5
          },
          {
            "startOffset": 5530,
            "endOffset": 5586,
            "count": 5
          },
          {
            "startOffset": 5586,
            "endOffset": 5637,
            "count": 8
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5776,
            "endOffset": 6002,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5895,
            "endOffset": 5913,
            "count": 5
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6015,
            "endOffset": 6366,
            "count": 3
          },
          {
            "startOffset": 6077,
            "endOffset": 6289,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 3
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 9
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 6
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 3
          },
          {
            "startOffset": 10345,
            "endOffset": 10408,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 3
          },
          {
            "startOffset": 7990,
            "endOffset": 8004,
            "count": 0
          },
          {
            "startOffset": 8006,
            "endOffset": 8020,
            "count": 0
          },
          {
            "startOffset": 8616,
            "endOffset": 8623,
            "count": 1
          },
          {
            "startOffset": 8660,
            "endOffset": 10188,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8957,
            "endOffset": 9835,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 3
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 3
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 3
          },
          {
            "startOffset": 840,
            "endOffset": 847,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 850,
            "endOffset": 861,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 917,
            "endOffset": 1119,
            "count": 6
          },
          {
            "startOffset": 963,
            "endOffset": 1029,
            "count": 5
          },
          {
            "startOffset": 1029,
            "endOffset": 1113,
            "count": 1
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 49
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2878,
            "endOffset": 3721,
            "count": 3
          },
          {
            "startOffset": 2977,
            "endOffset": 2987,
            "count": 1
          },
          {
            "startOffset": 2987,
            "endOffset": 3720,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3018,
            "endOffset": 3695,
            "count": 3
          },
          {
            "startOffset": 3413,
            "endOffset": 3429,
            "count": 0
          },
          {
            "startOffset": 3431,
            "endOffset": 3655,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3471,
            "endOffset": 3641,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3907,
            "endOffset": 4020,
            "count": 2
          },
          {
            "startOffset": 3986,
            "endOffset": 3997,
            "count": 1
          },
          {
            "startOffset": 3998,
            "endOffset": 4011,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4178,
            "endOffset": 4261,
            "count": 4
          },
          {
            "startOffset": 4250,
            "endOffset": 4254,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4423,
            "endOffset": 4506,
            "count": 5
          },
          {
            "startOffset": 4485,
            "endOffset": 4489,
            "count": 4
          },
          {
            "startOffset": 4490,
            "endOffset": 4499,
            "count": 1
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 22
          },
          {
            "startOffset": 4706,
            "endOffset": 5322,
            "count": 15
          },
          {
            "startOffset": 5322,
            "endOffset": 6370,
            "count": 7
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4763,
            "endOffset": 5315,
            "count": 15
          },
          {
            "startOffset": 4827,
            "endOffset": 4977,
            "count": 1
          },
          {
            "startOffset": 4977,
            "endOffset": 5314,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5202,
            "endOffset": 5282,
            "count": 4
          },
          {
            "startOffset": 5255,
            "endOffset": 5266,
            "count": 1
          },
          {
            "startOffset": 5267,
            "endOffset": 5271,
            "count": 3
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5457,
            "endOffset": 5667,
            "count": 21
          },
          {
            "startOffset": 5503,
            "endOffset": 5528,
            "count": 7
          },
          {
            "startOffset": 5530,
            "endOffset": 5586,
            "count": 7
          },
          {
            "startOffset": 5586,
            "endOffset": 5637,
            "count": 14
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5776,
            "endOffset": 6002,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5895,
            "endOffset": 5913,
            "count": 8
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6015,
            "endOffset": 6366,
            "count": 9
          },
          {
            "startOffset": 6077,
            "endOffset": 6289,
            "count": 1
          },
          {
            "startOffset": 6289,
            "endOffset": 6365,
            "count": 8
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 7
          },
          {
            "startOffset": 6461,
            "endOffset": 6476,
            "count": 2
          },
          {
            "startOffset": 6478,
            "endOffset": 6504,
            "count": 2
          },
          {
            "startOffset": 6504,
            "endOffset": 6544,
            "count": 5
          },
          {
            "startOffset": 6544,
            "endOffset": 6585,
            "count": 1
          },
          {
            "startOffset": 6585,
            "endOffset": 6678,
            "count": 4
          },
          {
            "startOffset": 6678,
            "endOffset": 6704,
            "count": 1
          },
          {
            "startOffset": 6704,
            "endOffset": 6769,
            "count": 3
          },
          {
            "startOffset": 6742,
            "endOffset": 6769,
            "count": 1
          },
          {
            "startOffset": 6769,
            "endOffset": 6863,
            "count": 2
          },
          {
            "startOffset": 6863,
            "endOffset": 6898,
            "count": 0
          },
          {
            "startOffset": 6900,
            "endOffset": 6972,
            "count": 2
          },
          {
            "startOffset": 6936,
            "endOffset": 6971,
            "count": 0
          },
          {
            "startOffset": 6979,
            "endOffset": 7018,
            "count": 0
          },
          {
            "startOffset": 7018,
            "endOffset": 7040,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 38
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 99
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 61
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 58
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 20
          },
          {
            "startOffset": 7848,
            "endOffset": 10345,
            "count": 19
          },
          {
            "startOffset": 10345,
            "endOffset": 10408,
            "count": 1
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 21
          },
          {
            "startOffset": 7990,
            "endOffset": 8004,
            "count": 2
          },
          {
            "startOffset": 8006,
            "endOffset": 8020,
            "count": 2
          },
          {
            "startOffset": 8020,
            "endOffset": 8096,
            "count": 19
          },
          {
            "startOffset": 8096,
            "endOffset": 10202,
            "count": 18
          },
          {
            "startOffset": 8153,
            "endOffset": 8660,
            "count": 13
          },
          {
            "startOffset": 8616,
            "endOffset": 8623,
            "count": 0
          },
          {
            "startOffset": 8660,
            "endOffset": 10188,
            "count": 5
          },
          {
            "startOffset": 8780,
            "endOffset": 8841,
            "count": 4
          },
          {
            "startOffset": 8858,
            "endOffset": 9894,
            "count": 4
          },
          {
            "startOffset": 9894,
            "endOffset": 10188,
            "count": 1
          },
          {
            "startOffset": 10202,
            "endOffset": 10265,
            "count": 16
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8957,
            "endOffset": 9835,
            "count": 4
          },
          {
            "startOffset": 9056,
            "endOffset": 9083,
            "count": 1
          },
          {
            "startOffset": 9085,
            "endOffset": 9182,
            "count": 1
          },
          {
            "startOffset": 9382,
            "endOffset": 9574,
            "count": 1
          },
          {
            "startOffset": 9574,
            "endOffset": 9776,
            "count": 3
          },
          {
            "startOffset": 9677,
            "endOffset": 9684,
            "count": 1
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 50
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 24
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 1
          },
          {
            "startOffset": 12758,
            "endOffset": 12811,
            "count": 49
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 63
          },
          {
            "startOffset": 11035,
            "endOffset": 11095,
            "count": 62
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 47
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 1
          },
          {
            "startOffset": 11664,
            "endOffset": 11808,
            "count": 0
          },
          {
            "startOffset": 11862,
            "endOffset": 11895,
            "count": 0
          },
          {
            "startOffset": 11989,
            "endOffset": 12045,
            "count": 0
          },
          {
            "startOffset": 12353,
            "endOffset": 12659,
            "count": 0
          },
          {
            "startOffset": 12660,
            "endOffset": 12667,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 2
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13688,
            "endOffset": 13719,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 38
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14945,
            "endOffset": 14978,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15142,
            "endOffset": 15198,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15213,
            "endOffset": 15504,
            "count": 1
          },
          {
            "startOffset": 15344,
            "endOffset": 15402,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15746,
            "endOffset": 15777,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 38
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 11
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 5
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 5
          },
          {
            "startOffset": 16219,
            "endOffset": 16712,
            "count": 6
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 0
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 0
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 0
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 1
          },
          {
            "startOffset": 16615,
            "endOffset": 16702,
            "count": 5
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 10
          },
          {
            "startOffset": 17417,
            "endOffset": 17424,
            "count": 1
          },
          {
            "startOffset": 17424,
            "endOffset": 17452,
            "count": 9
          },
          {
            "startOffset": 17452,
            "endOffset": 17485,
            "count": 7
          },
          {
            "startOffset": 17487,
            "endOffset": 17535,
            "count": 2
          },
          {
            "startOffset": 17535,
            "endOffset": 17640,
            "count": 9
          },
          {
            "startOffset": 17640,
            "endOffset": 18164,
            "count": 3
          },
          {
            "startOffset": 17751,
            "endOffset": 17873,
            "count": 2
          },
          {
            "startOffset": 17873,
            "endOffset": 18156,
            "count": 1
          },
          {
            "startOffset": 18164,
            "endOffset": 18250,
            "count": 9
          },
          {
            "startOffset": 18250,
            "endOffset": 18275,
            "count": 0
          },
          {
            "startOffset": 18275,
            "endOffset": 18303,
            "count": 9
          },
          {
            "startOffset": 18303,
            "endOffset": 18345,
            "count": 2
          },
          {
            "startOffset": 18345,
            "endOffset": 18395,
            "count": 7
          },
          {
            "startOffset": 18395,
            "endOffset": 18429,
            "count": 9
          },
          {
            "startOffset": 18429,
            "endOffset": 18490,
            "count": 0
          },
          {
            "startOffset": 18490,
            "endOffset": 18528,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18054,
            "endOffset": 18091,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 10
          },
          {
            "startOffset": 492,
            "endOffset": 561,
            "count": 150
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 9
          },
          {
            "startOffset": 848,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 850,
            "endOffset": 861,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 917,
            "endOffset": 1119,
            "count": 45
          },
          {
            "startOffset": 963,
            "endOffset": 1029,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 20
          },
          {
            "startOffset": 1494,
            "endOffset": 1501,
            "count": 11
          },
          {
            "startOffset": 1501,
            "endOffset": 1825,
            "count": 9
          },
          {
            "startOffset": 1772,
            "endOffset": 1777,
            "count": 0
          },
          {
            "startOffset": 1825,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 18
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 2
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 5
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 3
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 20
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 10
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 30
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 30
          },
          {
            "startOffset": 11347,
            "endOffset": 11664,
            "count": 10
          },
          {
            "startOffset": 11664,
            "endOffset": 11808,
            "count": 20
          },
          {
            "startOffset": 11734,
            "endOffset": 11808,
            "count": 10
          },
          {
            "startOffset": 11862,
            "endOffset": 11895,
            "count": 10
          },
          {
            "startOffset": 11895,
            "endOffset": 12045,
            "count": 20
          },
          {
            "startOffset": 12058,
            "endOffset": 12686,
            "count": 10
          },
          {
            "startOffset": 12176,
            "endOffset": 12353,
            "count": 0
          },
          {
            "startOffset": 12464,
            "endOffset": 12501,
            "count": 0
          },
          {
            "startOffset": 12652,
            "endOffset": 12659,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 11
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 20
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 10
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 10
          },
          {
            "startOffset": 16428,
            "endOffset": 16712,
            "count": 10
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    customTagMatch = /<\\s*[a-z]+-[a-z][^>]*>/g,\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (!!result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        const lookup = [];\n\n        args[0].forEach((item, index, items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (!!attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 19019,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 19016,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 369,
            "endOffset": 583,
            "count": 1
          },
          {
            "startOffset": 492,
            "endOffset": 561,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 762,
            "endOffset": 1172,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1351,
            "endOffset": 2601,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1453,
            "endOffset": 2209,
            "count": 4
          },
          {
            "startOffset": 1501,
            "endOffset": 2208,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1585,
            "endOffset": 1615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2657,
            "endOffset": 4532,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4536,
            "endOffset": 6371,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6396,
            "endOffset": 7041,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7242,
            "endOffset": 13911,
            "count": 4
          },
          {
            "startOffset": 13811,
            "endOffset": 13887,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7693,
            "endOffset": 7779,
            "count": 9
          },
          {
            "startOffset": 7738,
            "endOffset": 7757,
            "count": 5
          },
          {
            "startOffset": 7758,
            "endOffset": 7778,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7803,
            "endOffset": 10443,
            "count": 1
          },
          {
            "startOffset": 7848,
            "endOffset": 10345,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7941,
            "endOffset": 10266,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10450,
            "endOffset": 10526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10886,
            "endOffset": 12812,
            "count": 4
          },
          {
            "startOffset": 11108,
            "endOffset": 11159,
            "count": 2
          },
          {
            "startOffset": 11168,
            "endOffset": 12758,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10984,
            "endOffset": 11095,
            "count": 3
          },
          {
            "startOffset": 11035,
            "endOffset": 11095,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11132,
            "endOffset": 11158,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11283,
            "endOffset": 12733,
            "count": 5
          },
          {
            "startOffset": 11347,
            "endOffset": 11664,
            "count": 2
          },
          {
            "startOffset": 11664,
            "endOffset": 11808,
            "count": 3
          },
          {
            "startOffset": 11734,
            "endOffset": 11808,
            "count": 2
          },
          {
            "startOffset": 11862,
            "endOffset": 11895,
            "count": 2
          },
          {
            "startOffset": 11895,
            "endOffset": 11989,
            "count": 3
          },
          {
            "startOffset": 11989,
            "endOffset": 12045,
            "count": 2
          },
          {
            "startOffset": 12058,
            "endOffset": 12686,
            "count": 3
          },
          {
            "startOffset": 12176,
            "endOffset": 12353,
            "count": 0
          },
          {
            "startOffset": 12464,
            "endOffset": 12501,
            "count": 2
          },
          {
            "startOffset": 12501,
            "endOffset": 12659,
            "count": 1
          },
          {
            "startOffset": 12660,
            "endOffset": 12667,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12850,
            "endOffset": 12918,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12940,
            "endOffset": 13003,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13232,
            "endOffset": 13788,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13291,
            "endOffset": 13334,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13499,
            "endOffset": 13526,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13545,
            "endOffset": 13780,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14254,
            "endOffset": 14335,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14673,
            "endOffset": 14734,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14859,
            "endOffset": 15554,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15578,
            "endOffset": 15840,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15659,
            "endOffset": 15788,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15864,
            "endOffset": 16752,
            "count": 4
          },
          {
            "startOffset": 15971,
            "endOffset": 16720,
            "count": 3
          },
          {
            "startOffset": 16053,
            "endOffset": 16062,
            "count": 0
          },
          {
            "startOffset": 16064,
            "endOffset": 16219,
            "count": 0
          },
          {
            "startOffset": 16270,
            "endOffset": 16301,
            "count": 2
          },
          {
            "startOffset": 16303,
            "endOffset": 16346,
            "count": 1
          },
          {
            "startOffset": 16347,
            "endOffset": 16417,
            "count": 1
          },
          {
            "startOffset": 16428,
            "endOffset": 16503,
            "count": 1
          },
          {
            "startOffset": 16503,
            "endOffset": 16712,
            "count": 2
          },
          {
            "startOffset": 16562,
            "endOffset": 16615,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17145,
            "endOffset": 18546,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18584,
            "endOffset": 18783,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 1
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 4
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 5
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 4
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 2
          },
          {
            "startOffset": 11271,
            "endOffset": 11732,
            "count": 1
          },
          {
            "startOffset": 11786,
            "endOffset": 11913,
            "count": 1
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 0
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 1
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 1
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 1
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 1
          },
          {
            "startOffset": 16352,
            "endOffset": 16636,
            "count": 1
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 7
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2830,
            "endOffset": 3673,
            "count": 2
          },
          {
            "startOffset": 2929,
            "endOffset": 2939,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2970,
            "endOffset": 3647,
            "count": 5
          },
          {
            "startOffset": 3365,
            "endOffset": 3381,
            "count": 2
          },
          {
            "startOffset": 3383,
            "endOffset": 3607,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3423,
            "endOffset": 3593,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3859,
            "endOffset": 3972,
            "count": 1
          },
          {
            "startOffset": 3938,
            "endOffset": 3949,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4130,
            "endOffset": 4213,
            "count": 2
          },
          {
            "startOffset": 4192,
            "endOffset": 4201,
            "count": 1
          },
          {
            "startOffset": 4202,
            "endOffset": 4206,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4458,
            "count": 1
          },
          {
            "startOffset": 4437,
            "endOffset": 4441,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 7
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 6
          },
          {
            "startOffset": 5274,
            "endOffset": 6323,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 6
          },
          {
            "startOffset": 4779,
            "endOffset": 4929,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5154,
            "endOffset": 5234,
            "count": 1
          },
          {
            "startOffset": 5219,
            "endOffset": 5223,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 3
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 1
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 1
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 1
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 7
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 14
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 7
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 7
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 7
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 7
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 4
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 60
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 6
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 6
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 13
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 7
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 6
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 6
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 7
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 3
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 4
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 3
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 4
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 3
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 4
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 3
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 6
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 6
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 5
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 4
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 4
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 4
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 4
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 1
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 1
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 3
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 1
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 1
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 1
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 2
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 6
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 5
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 2
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1446,
            "endOffset": 1453,
            "count": 2
          },
          {
            "startOffset": 1453,
            "endOffset": 1606,
            "count": 1
          },
          {
            "startOffset": 1606,
            "endOffset": 1777,
            "count": 0
          },
          {
            "startOffset": 1777,
            "endOffset": 1923,
            "count": 1
          },
          {
            "startOffset": 1923,
            "endOffset": 1994,
            "count": 0
          },
          {
            "startOffset": 1994,
            "endOffset": 2160,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 1
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 8
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 1
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 3
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 1
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 10
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 150
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 9
          },
          {
            "startOffset": 800,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 45
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 20
          },
          {
            "startOffset": 1446,
            "endOffset": 1453,
            "count": 11
          },
          {
            "startOffset": 1453,
            "endOffset": 1777,
            "count": 9
          },
          {
            "startOffset": 1724,
            "endOffset": 1729,
            "count": 0
          },
          {
            "startOffset": 1777,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 18
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 5
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 3
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 20
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 10
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 30
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 30
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 10
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 20
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 10
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 10
          },
          {
            "startOffset": 11819,
            "endOffset": 11969,
            "count": 20
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 10
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 11
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 20
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 10
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 10
          },
          {
            "startOffset": 16352,
            "endOffset": 16636,
            "count": 10
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 3
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 13
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 5
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 5
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 8
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 5
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 3
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 3
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 6
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 3
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 3
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 1
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 3
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 3
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 6
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 1
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 49
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2830,
            "endOffset": 3673,
            "count": 3
          },
          {
            "startOffset": 2929,
            "endOffset": 2939,
            "count": 1
          },
          {
            "startOffset": 2939,
            "endOffset": 3672,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2970,
            "endOffset": 3647,
            "count": 3
          },
          {
            "startOffset": 3365,
            "endOffset": 3381,
            "count": 0
          },
          {
            "startOffset": 3383,
            "endOffset": 3607,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3423,
            "endOffset": 3593,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3859,
            "endOffset": 3972,
            "count": 2
          },
          {
            "startOffset": 3938,
            "endOffset": 3949,
            "count": 1
          },
          {
            "startOffset": 3950,
            "endOffset": 3963,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4130,
            "endOffset": 4213,
            "count": 4
          },
          {
            "startOffset": 4202,
            "endOffset": 4206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4458,
            "count": 5
          },
          {
            "startOffset": 4437,
            "endOffset": 4441,
            "count": 4
          },
          {
            "startOffset": 4442,
            "endOffset": 4451,
            "count": 1
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 22
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 15
          },
          {
            "startOffset": 5274,
            "endOffset": 6323,
            "count": 7
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 15
          },
          {
            "startOffset": 4779,
            "endOffset": 4929,
            "count": 1
          },
          {
            "startOffset": 4929,
            "endOffset": 5266,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5154,
            "endOffset": 5234,
            "count": 4
          },
          {
            "startOffset": 5207,
            "endOffset": 5218,
            "count": 1
          },
          {
            "startOffset": 5219,
            "endOffset": 5223,
            "count": 3
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 21
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 7
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 7
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 14
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 8
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 9
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 1
          },
          {
            "startOffset": 6242,
            "endOffset": 6318,
            "count": 8
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 7
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 2
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 2
          },
          {
            "startOffset": 6457,
            "endOffset": 6497,
            "count": 5
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 1
          },
          {
            "startOffset": 6538,
            "endOffset": 6631,
            "count": 4
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 1
          },
          {
            "startOffset": 6657,
            "endOffset": 6722,
            "count": 3
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 1
          },
          {
            "startOffset": 6722,
            "endOffset": 6816,
            "count": 2
          },
          {
            "startOffset": 6816,
            "endOffset": 6851,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 2
          },
          {
            "startOffset": 6889,
            "endOffset": 6924,
            "count": 0
          },
          {
            "startOffset": 6932,
            "endOffset": 6971,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 38
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 99
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 61
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 58
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 20
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 19
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 1
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 21
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 2
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 2
          },
          {
            "startOffset": 7973,
            "endOffset": 8047,
            "count": 19
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 18
          },
          {
            "startOffset": 8104,
            "endOffset": 8611,
            "count": 13
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 0
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 5
          },
          {
            "startOffset": 8731,
            "endOffset": 8792,
            "count": 4
          },
          {
            "startOffset": 8809,
            "endOffset": 9845,
            "count": 4
          },
          {
            "startOffset": 9845,
            "endOffset": 10139,
            "count": 1
          },
          {
            "startOffset": 10153,
            "endOffset": 10216,
            "count": 16
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 4
          },
          {
            "startOffset": 9007,
            "endOffset": 9034,
            "count": 1
          },
          {
            "startOffset": 9036,
            "endOffset": 9133,
            "count": 1
          },
          {
            "startOffset": 9333,
            "endOffset": 9525,
            "count": 1
          },
          {
            "startOffset": 9525,
            "endOffset": 9727,
            "count": 3
          },
          {
            "startOffset": 9628,
            "endOffset": 9635,
            "count": 1
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 50
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 24
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 1
          },
          {
            "startOffset": 12682,
            "endOffset": 12735,
            "count": 49
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 63
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 62
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 47
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 1
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 0
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 0
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 0
          },
          {
            "startOffset": 12277,
            "endOffset": 12583,
            "count": 0
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 2
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13612,
            "endOffset": 13643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 38
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 1
          },
          {
            "startOffset": 15268,
            "endOffset": 15326,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 38
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 11
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 5
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 5
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 6
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 1
          },
          {
            "startOffset": 16539,
            "endOffset": 16626,
            "count": 5
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 10
          },
          {
            "startOffset": 17341,
            "endOffset": 17348,
            "count": 1
          },
          {
            "startOffset": 17348,
            "endOffset": 17376,
            "count": 9
          },
          {
            "startOffset": 17376,
            "endOffset": 17409,
            "count": 7
          },
          {
            "startOffset": 17411,
            "endOffset": 17459,
            "count": 2
          },
          {
            "startOffset": 17459,
            "endOffset": 17564,
            "count": 9
          },
          {
            "startOffset": 17564,
            "endOffset": 18088,
            "count": 3
          },
          {
            "startOffset": 17675,
            "endOffset": 17797,
            "count": 2
          },
          {
            "startOffset": 17797,
            "endOffset": 18080,
            "count": 1
          },
          {
            "startOffset": 18088,
            "endOffset": 18174,
            "count": 9
          },
          {
            "startOffset": 18174,
            "endOffset": 18199,
            "count": 0
          },
          {
            "startOffset": 18199,
            "endOffset": 18227,
            "count": 9
          },
          {
            "startOffset": 18227,
            "endOffset": 18269,
            "count": 2
          },
          {
            "startOffset": 18269,
            "endOffset": 18319,
            "count": 7
          },
          {
            "startOffset": 18319,
            "endOffset": 18351,
            "count": 9
          },
          {
            "startOffset": 18351,
            "endOffset": 18412,
            "count": 0
          },
          {
            "startOffset": 18412,
            "endOffset": 18450,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17978,
            "endOffset": 18015,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 1
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 4
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 5
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 2
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 5
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 2
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 2
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 2
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 3
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 2
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 3
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 2
          },
          {
            "startOffset": 12425,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 3
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 2
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 1
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 1
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 1
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 2
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 1
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 4
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 5
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 4
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 2
          },
          {
            "startOffset": 11271,
            "endOffset": 11732,
            "count": 1
          },
          {
            "startOffset": 11786,
            "endOffset": 11913,
            "count": 1
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 0
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 1
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 1
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 1
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 1
          },
          {
            "startOffset": 16352,
            "endOffset": 16636,
            "count": 1
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 3
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 0
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 0
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 0
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 0
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 3
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 6
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 3
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 3
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13612,
            "endOffset": 13643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 2
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 3
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 3
          },
          {
            "startOffset": 15268,
            "endOffset": 15326,
            "count": 1
          },
          {
            "startOffset": 15326,
            "endOffset": 15406,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 2
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 3
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 4
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 60
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 6
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 6
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 13
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 7
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 6
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 6
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 7
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 3
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 4
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 3
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 4
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 3
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 4
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 3
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 6
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 6
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 5
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 4
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 4
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 4
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 4
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 1
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 2
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 7
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 0
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 0
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 0
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 0
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 4
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 1
          },
          {
            "startOffset": 800,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 2
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 3
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 1
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 3
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 1
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 1
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 1
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 2
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 6
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 5
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 2
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1446,
            "endOffset": 1453,
            "count": 2
          },
          {
            "startOffset": 1453,
            "endOffset": 1606,
            "count": 1
          },
          {
            "startOffset": 1606,
            "endOffset": 1777,
            "count": 0
          },
          {
            "startOffset": 1777,
            "endOffset": 1923,
            "count": 1
          },
          {
            "startOffset": 1923,
            "endOffset": 1994,
            "count": 0
          },
          {
            "startOffset": 1994,
            "endOffset": 2160,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 1
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 8
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 1
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 3
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 1
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 3
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 13
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 5
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 5
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 8
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 5
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 3
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 3
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 6
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 3
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 3
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 1
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 3
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 3
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 6
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 1
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 49
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2830,
            "endOffset": 3673,
            "count": 3
          },
          {
            "startOffset": 2929,
            "endOffset": 2939,
            "count": 1
          },
          {
            "startOffset": 2939,
            "endOffset": 3672,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2970,
            "endOffset": 3647,
            "count": 3
          },
          {
            "startOffset": 3365,
            "endOffset": 3381,
            "count": 0
          },
          {
            "startOffset": 3383,
            "endOffset": 3607,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3423,
            "endOffset": 3593,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3859,
            "endOffset": 3972,
            "count": 2
          },
          {
            "startOffset": 3938,
            "endOffset": 3949,
            "count": 1
          },
          {
            "startOffset": 3950,
            "endOffset": 3963,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4130,
            "endOffset": 4213,
            "count": 4
          },
          {
            "startOffset": 4202,
            "endOffset": 4206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4458,
            "count": 5
          },
          {
            "startOffset": 4437,
            "endOffset": 4441,
            "count": 4
          },
          {
            "startOffset": 4442,
            "endOffset": 4451,
            "count": 1
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 22
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 15
          },
          {
            "startOffset": 5274,
            "endOffset": 6323,
            "count": 7
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 15
          },
          {
            "startOffset": 4779,
            "endOffset": 4929,
            "count": 1
          },
          {
            "startOffset": 4929,
            "endOffset": 5266,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5154,
            "endOffset": 5234,
            "count": 4
          },
          {
            "startOffset": 5207,
            "endOffset": 5218,
            "count": 1
          },
          {
            "startOffset": 5219,
            "endOffset": 5223,
            "count": 3
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 21
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 7
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 7
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 14
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 8
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 9
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 1
          },
          {
            "startOffset": 6242,
            "endOffset": 6318,
            "count": 8
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 7
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 2
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 2
          },
          {
            "startOffset": 6457,
            "endOffset": 6497,
            "count": 5
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 1
          },
          {
            "startOffset": 6538,
            "endOffset": 6631,
            "count": 4
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 1
          },
          {
            "startOffset": 6657,
            "endOffset": 6722,
            "count": 3
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 1
          },
          {
            "startOffset": 6722,
            "endOffset": 6816,
            "count": 2
          },
          {
            "startOffset": 6816,
            "endOffset": 6851,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 2
          },
          {
            "startOffset": 6889,
            "endOffset": 6924,
            "count": 0
          },
          {
            "startOffset": 6932,
            "endOffset": 6971,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 38
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 99
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 61
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 58
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 20
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 19
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 1
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 21
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 2
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 2
          },
          {
            "startOffset": 7973,
            "endOffset": 8047,
            "count": 19
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 18
          },
          {
            "startOffset": 8104,
            "endOffset": 8611,
            "count": 13
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 0
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 5
          },
          {
            "startOffset": 8731,
            "endOffset": 8792,
            "count": 4
          },
          {
            "startOffset": 8809,
            "endOffset": 9845,
            "count": 4
          },
          {
            "startOffset": 9845,
            "endOffset": 10139,
            "count": 1
          },
          {
            "startOffset": 10153,
            "endOffset": 10216,
            "count": 16
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 4
          },
          {
            "startOffset": 9007,
            "endOffset": 9034,
            "count": 1
          },
          {
            "startOffset": 9036,
            "endOffset": 9133,
            "count": 1
          },
          {
            "startOffset": 9333,
            "endOffset": 9525,
            "count": 1
          },
          {
            "startOffset": 9525,
            "endOffset": 9727,
            "count": 3
          },
          {
            "startOffset": 9628,
            "endOffset": 9635,
            "count": 1
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 50
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 24
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 1
          },
          {
            "startOffset": 12682,
            "endOffset": 12735,
            "count": 49
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 63
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 62
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 47
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 1
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 0
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 0
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 0
          },
          {
            "startOffset": 12277,
            "endOffset": 12583,
            "count": 0
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 2
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13612,
            "endOffset": 13643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 38
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 1
          },
          {
            "startOffset": 15268,
            "endOffset": 15326,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 38
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 11
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 5
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 5
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 6
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 1
          },
          {
            "startOffset": 16539,
            "endOffset": 16626,
            "count": 5
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 10
          },
          {
            "startOffset": 17341,
            "endOffset": 17348,
            "count": 1
          },
          {
            "startOffset": 17348,
            "endOffset": 17376,
            "count": 9
          },
          {
            "startOffset": 17376,
            "endOffset": 17409,
            "count": 7
          },
          {
            "startOffset": 17411,
            "endOffset": 17459,
            "count": 2
          },
          {
            "startOffset": 17459,
            "endOffset": 17564,
            "count": 9
          },
          {
            "startOffset": 17564,
            "endOffset": 18088,
            "count": 3
          },
          {
            "startOffset": 17675,
            "endOffset": 17797,
            "count": 2
          },
          {
            "startOffset": 17797,
            "endOffset": 18080,
            "count": 1
          },
          {
            "startOffset": 18088,
            "endOffset": 18174,
            "count": 9
          },
          {
            "startOffset": 18174,
            "endOffset": 18199,
            "count": 0
          },
          {
            "startOffset": 18199,
            "endOffset": 18227,
            "count": 9
          },
          {
            "startOffset": 18227,
            "endOffset": 18269,
            "count": 2
          },
          {
            "startOffset": 18269,
            "endOffset": 18319,
            "count": 7
          },
          {
            "startOffset": 18319,
            "endOffset": 18351,
            "count": 9
          },
          {
            "startOffset": 18351,
            "endOffset": 18412,
            "count": 0
          },
          {
            "startOffset": 18412,
            "endOffset": 18450,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17978,
            "endOffset": 18015,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 10
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 150
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 9
          },
          {
            "startOffset": 800,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 45
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 20
          },
          {
            "startOffset": 1446,
            "endOffset": 1453,
            "count": 11
          },
          {
            "startOffset": 1453,
            "endOffset": 1777,
            "count": 9
          },
          {
            "startOffset": 1724,
            "endOffset": 1729,
            "count": 0
          },
          {
            "startOffset": 1777,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 18
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 5
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 3
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 20
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 10
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 30
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 30
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 10
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 20
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 10
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 10
          },
          {
            "startOffset": 11819,
            "endOffset": 11969,
            "count": 20
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 10
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 11
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 20
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 10
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 10
          },
          {
            "startOffset": 16352,
            "endOffset": 16636,
            "count": 10
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 1
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 4
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 5
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 2
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 5
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 2
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 2
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 2
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 3
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 2
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 3
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 2
          },
          {
            "startOffset": 12425,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 3
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 2
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 1
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 1
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 1
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 2
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 7
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2830,
            "endOffset": 3673,
            "count": 2
          },
          {
            "startOffset": 2929,
            "endOffset": 2939,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2970,
            "endOffset": 3647,
            "count": 5
          },
          {
            "startOffset": 3365,
            "endOffset": 3381,
            "count": 2
          },
          {
            "startOffset": 3383,
            "endOffset": 3607,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3423,
            "endOffset": 3593,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3859,
            "endOffset": 3972,
            "count": 1
          },
          {
            "startOffset": 3938,
            "endOffset": 3949,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4130,
            "endOffset": 4213,
            "count": 2
          },
          {
            "startOffset": 4192,
            "endOffset": 4201,
            "count": 1
          },
          {
            "startOffset": 4202,
            "endOffset": 4206,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4458,
            "count": 1
          },
          {
            "startOffset": 4437,
            "endOffset": 4441,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 7
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 6
          },
          {
            "startOffset": 5274,
            "endOffset": 6323,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 6
          },
          {
            "startOffset": 4779,
            "endOffset": 4929,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5154,
            "endOffset": 5234,
            "count": 1
          },
          {
            "startOffset": 5219,
            "endOffset": 5223,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 3
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 1
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 1
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 1
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 7
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 14
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 7
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 7
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 7
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 7
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 4
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 60
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 6
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 6
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 13
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 7
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 6
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 6
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 7
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 3
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 4
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 3
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 4
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 3
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 4
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 3
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 6
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 6
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 5
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 4
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 4
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 4
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 4
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 1
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 2
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 7
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 0
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 0
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 0
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 0
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 4
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 1
          },
          {
            "startOffset": 800,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 2
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 3
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 1
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 3
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 1
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 1
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 1
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 2
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 6
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 5
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 2
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1446,
            "endOffset": 1453,
            "count": 2
          },
          {
            "startOffset": 1453,
            "endOffset": 1606,
            "count": 1
          },
          {
            "startOffset": 1606,
            "endOffset": 1777,
            "count": 0
          },
          {
            "startOffset": 1777,
            "endOffset": 1923,
            "count": 1
          },
          {
            "startOffset": 1923,
            "endOffset": 1994,
            "count": 0
          },
          {
            "startOffset": 1994,
            "endOffset": 2160,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 1
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 8
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 1
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 3
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 1
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 3
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 13
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 5
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 5
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 8
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 5
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 3
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 3
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 6
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 3
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 3
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 1
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 3
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 3
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 6
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 1
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 49
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2830,
            "endOffset": 3673,
            "count": 3
          },
          {
            "startOffset": 2929,
            "endOffset": 2939,
            "count": 1
          },
          {
            "startOffset": 2939,
            "endOffset": 3672,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2970,
            "endOffset": 3647,
            "count": 3
          },
          {
            "startOffset": 3365,
            "endOffset": 3381,
            "count": 0
          },
          {
            "startOffset": 3383,
            "endOffset": 3607,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3423,
            "endOffset": 3593,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3859,
            "endOffset": 3972,
            "count": 2
          },
          {
            "startOffset": 3938,
            "endOffset": 3949,
            "count": 1
          },
          {
            "startOffset": 3950,
            "endOffset": 3963,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4130,
            "endOffset": 4213,
            "count": 4
          },
          {
            "startOffset": 4202,
            "endOffset": 4206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4458,
            "count": 5
          },
          {
            "startOffset": 4437,
            "endOffset": 4441,
            "count": 4
          },
          {
            "startOffset": 4442,
            "endOffset": 4451,
            "count": 1
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 22
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 15
          },
          {
            "startOffset": 5274,
            "endOffset": 6323,
            "count": 7
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 15
          },
          {
            "startOffset": 4779,
            "endOffset": 4929,
            "count": 1
          },
          {
            "startOffset": 4929,
            "endOffset": 5266,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5154,
            "endOffset": 5234,
            "count": 4
          },
          {
            "startOffset": 5207,
            "endOffset": 5218,
            "count": 1
          },
          {
            "startOffset": 5219,
            "endOffset": 5223,
            "count": 3
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 21
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 7
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 7
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 14
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 8
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 9
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 1
          },
          {
            "startOffset": 6242,
            "endOffset": 6318,
            "count": 8
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 7
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 2
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 2
          },
          {
            "startOffset": 6457,
            "endOffset": 6497,
            "count": 5
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 1
          },
          {
            "startOffset": 6538,
            "endOffset": 6631,
            "count": 4
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 1
          },
          {
            "startOffset": 6657,
            "endOffset": 6722,
            "count": 3
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 1
          },
          {
            "startOffset": 6722,
            "endOffset": 6816,
            "count": 2
          },
          {
            "startOffset": 6816,
            "endOffset": 6851,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 2
          },
          {
            "startOffset": 6889,
            "endOffset": 6924,
            "count": 0
          },
          {
            "startOffset": 6932,
            "endOffset": 6971,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 38
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 99
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 61
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 58
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 20
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 19
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 1
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 21
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 2
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 2
          },
          {
            "startOffset": 7973,
            "endOffset": 8047,
            "count": 19
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 18
          },
          {
            "startOffset": 8104,
            "endOffset": 8611,
            "count": 13
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 0
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 5
          },
          {
            "startOffset": 8731,
            "endOffset": 8792,
            "count": 4
          },
          {
            "startOffset": 8809,
            "endOffset": 9845,
            "count": 4
          },
          {
            "startOffset": 9845,
            "endOffset": 10139,
            "count": 1
          },
          {
            "startOffset": 10153,
            "endOffset": 10216,
            "count": 16
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 4
          },
          {
            "startOffset": 9007,
            "endOffset": 9034,
            "count": 1
          },
          {
            "startOffset": 9036,
            "endOffset": 9133,
            "count": 1
          },
          {
            "startOffset": 9333,
            "endOffset": 9525,
            "count": 1
          },
          {
            "startOffset": 9525,
            "endOffset": 9727,
            "count": 3
          },
          {
            "startOffset": 9628,
            "endOffset": 9635,
            "count": 1
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 50
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 24
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 1
          },
          {
            "startOffset": 12682,
            "endOffset": 12735,
            "count": 49
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 63
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 62
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 47
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 1
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 0
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 0
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 0
          },
          {
            "startOffset": 12277,
            "endOffset": 12583,
            "count": 0
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 2
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13612,
            "endOffset": 13643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 38
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 1
          },
          {
            "startOffset": 15268,
            "endOffset": 15326,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 38
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 11
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 5
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 5
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 6
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 1
          },
          {
            "startOffset": 16539,
            "endOffset": 16626,
            "count": 5
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 10
          },
          {
            "startOffset": 17341,
            "endOffset": 17348,
            "count": 1
          },
          {
            "startOffset": 17348,
            "endOffset": 17376,
            "count": 9
          },
          {
            "startOffset": 17376,
            "endOffset": 17409,
            "count": 7
          },
          {
            "startOffset": 17411,
            "endOffset": 17459,
            "count": 2
          },
          {
            "startOffset": 17459,
            "endOffset": 17564,
            "count": 9
          },
          {
            "startOffset": 17564,
            "endOffset": 18088,
            "count": 3
          },
          {
            "startOffset": 17675,
            "endOffset": 17797,
            "count": 2
          },
          {
            "startOffset": 17797,
            "endOffset": 18080,
            "count": 1
          },
          {
            "startOffset": 18088,
            "endOffset": 18174,
            "count": 9
          },
          {
            "startOffset": 18174,
            "endOffset": 18199,
            "count": 0
          },
          {
            "startOffset": 18199,
            "endOffset": 18227,
            "count": 9
          },
          {
            "startOffset": 18227,
            "endOffset": 18269,
            "count": 2
          },
          {
            "startOffset": 18269,
            "endOffset": 18319,
            "count": 7
          },
          {
            "startOffset": 18319,
            "endOffset": 18351,
            "count": 9
          },
          {
            "startOffset": 18351,
            "endOffset": 18412,
            "count": 0
          },
          {
            "startOffset": 18412,
            "endOffset": 18450,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17978,
            "endOffset": 18015,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 10
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 150
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 9
          },
          {
            "startOffset": 800,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 45
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 20
          },
          {
            "startOffset": 1446,
            "endOffset": 1453,
            "count": 11
          },
          {
            "startOffset": 1453,
            "endOffset": 1777,
            "count": 9
          },
          {
            "startOffset": 1724,
            "endOffset": 1729,
            "count": 0
          },
          {
            "startOffset": 1777,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 18
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 5
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 3
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 20
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 10
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 30
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 30
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 10
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 20
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 10
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 10
          },
          {
            "startOffset": 11819,
            "endOffset": 11969,
            "count": 20
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 10
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 11
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 20
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 10
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 10
          },
          {
            "startOffset": 16352,
            "endOffset": 16636,
            "count": 10
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 1
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 4
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 5
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 2
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 5
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 2
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 2
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 2
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 3
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 2
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 3
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 2
          },
          {
            "startOffset": 12425,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 3
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 2
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 1
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 1
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 1
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 2
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 4
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 60
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 6
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 6
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 13
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 7
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 6
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 6
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 7
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 3
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 4
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 3
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 4
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 3
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 4
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 3
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 6
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 6
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 5
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 4
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 4
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 4
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 4
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 1
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 7
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2830,
            "endOffset": 3673,
            "count": 2
          },
          {
            "startOffset": 2929,
            "endOffset": 2939,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2970,
            "endOffset": 3647,
            "count": 5
          },
          {
            "startOffset": 3365,
            "endOffset": 3381,
            "count": 2
          },
          {
            "startOffset": 3383,
            "endOffset": 3607,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3423,
            "endOffset": 3593,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3859,
            "endOffset": 3972,
            "count": 1
          },
          {
            "startOffset": 3938,
            "endOffset": 3949,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4130,
            "endOffset": 4213,
            "count": 2
          },
          {
            "startOffset": 4192,
            "endOffset": 4201,
            "count": 1
          },
          {
            "startOffset": 4202,
            "endOffset": 4206,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4458,
            "count": 1
          },
          {
            "startOffset": 4437,
            "endOffset": 4441,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 7
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 6
          },
          {
            "startOffset": 5274,
            "endOffset": 6323,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 6
          },
          {
            "startOffset": 4779,
            "endOffset": 4929,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5154,
            "endOffset": 5234,
            "count": 1
          },
          {
            "startOffset": 5219,
            "endOffset": 5223,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 3
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 1
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 1
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 1
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 7
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 14
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 7
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 7
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 7
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 7
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 3
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 0
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 0
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 0
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 0
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 3
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 6
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 3
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 3
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13612,
            "endOffset": 13643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 2
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 3
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 3
          },
          {
            "startOffset": 15268,
            "endOffset": 15326,
            "count": 1
          },
          {
            "startOffset": 15326,
            "endOffset": 15406,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 2
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 3
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 2
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 7
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 0
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 0
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 0
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 0
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 4
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 1
          },
          {
            "startOffset": 800,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 2
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 3
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1446,
            "endOffset": 1453,
            "count": 2
          },
          {
            "startOffset": 1453,
            "endOffset": 1606,
            "count": 1
          },
          {
            "startOffset": 1606,
            "endOffset": 1777,
            "count": 0
          },
          {
            "startOffset": 1777,
            "endOffset": 1923,
            "count": 1
          },
          {
            "startOffset": 1923,
            "endOffset": 1994,
            "count": 0
          },
          {
            "startOffset": 1994,
            "endOffset": 2160,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 1
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 1
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 3
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 1
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 1
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 1
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 8
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 1
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 2
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 6
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 5
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 2
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 3
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 1
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 3
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 6
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 1
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 49
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2830,
            "endOffset": 3673,
            "count": 3
          },
          {
            "startOffset": 2929,
            "endOffset": 2939,
            "count": 1
          },
          {
            "startOffset": 2939,
            "endOffset": 3672,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2970,
            "endOffset": 3647,
            "count": 3
          },
          {
            "startOffset": 3365,
            "endOffset": 3381,
            "count": 0
          },
          {
            "startOffset": 3383,
            "endOffset": 3607,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3423,
            "endOffset": 3593,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3859,
            "endOffset": 3972,
            "count": 2
          },
          {
            "startOffset": 3938,
            "endOffset": 3949,
            "count": 1
          },
          {
            "startOffset": 3950,
            "endOffset": 3963,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4130,
            "endOffset": 4213,
            "count": 4
          },
          {
            "startOffset": 4202,
            "endOffset": 4206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4458,
            "count": 5
          },
          {
            "startOffset": 4437,
            "endOffset": 4441,
            "count": 4
          },
          {
            "startOffset": 4442,
            "endOffset": 4451,
            "count": 1
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 22
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 15
          },
          {
            "startOffset": 5274,
            "endOffset": 6323,
            "count": 7
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 15
          },
          {
            "startOffset": 4779,
            "endOffset": 4929,
            "count": 1
          },
          {
            "startOffset": 4929,
            "endOffset": 5266,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5154,
            "endOffset": 5234,
            "count": 4
          },
          {
            "startOffset": 5207,
            "endOffset": 5218,
            "count": 1
          },
          {
            "startOffset": 5219,
            "endOffset": 5223,
            "count": 3
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 21
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 7
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 7
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 14
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 8
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 9
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 1
          },
          {
            "startOffset": 6242,
            "endOffset": 6318,
            "count": 8
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 7
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 2
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 2
          },
          {
            "startOffset": 6457,
            "endOffset": 6497,
            "count": 5
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 1
          },
          {
            "startOffset": 6538,
            "endOffset": 6631,
            "count": 4
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 1
          },
          {
            "startOffset": 6657,
            "endOffset": 6722,
            "count": 3
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 1
          },
          {
            "startOffset": 6722,
            "endOffset": 6816,
            "count": 2
          },
          {
            "startOffset": 6816,
            "endOffset": 6851,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 2
          },
          {
            "startOffset": 6889,
            "endOffset": 6924,
            "count": 0
          },
          {
            "startOffset": 6932,
            "endOffset": 6971,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 38
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 99
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 61
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 58
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 20
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 19
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 1
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 21
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 2
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 2
          },
          {
            "startOffset": 7973,
            "endOffset": 8047,
            "count": 19
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 18
          },
          {
            "startOffset": 8104,
            "endOffset": 8611,
            "count": 13
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 0
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 5
          },
          {
            "startOffset": 8731,
            "endOffset": 8792,
            "count": 4
          },
          {
            "startOffset": 8809,
            "endOffset": 9845,
            "count": 4
          },
          {
            "startOffset": 9845,
            "endOffset": 10139,
            "count": 1
          },
          {
            "startOffset": 10153,
            "endOffset": 10216,
            "count": 16
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 4
          },
          {
            "startOffset": 9007,
            "endOffset": 9034,
            "count": 1
          },
          {
            "startOffset": 9036,
            "endOffset": 9133,
            "count": 1
          },
          {
            "startOffset": 9333,
            "endOffset": 9525,
            "count": 1
          },
          {
            "startOffset": 9525,
            "endOffset": 9727,
            "count": 3
          },
          {
            "startOffset": 9628,
            "endOffset": 9635,
            "count": 1
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 50
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 24
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 1
          },
          {
            "startOffset": 12682,
            "endOffset": 12735,
            "count": 49
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 63
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 62
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 47
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 1
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 0
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 0
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 0
          },
          {
            "startOffset": 12277,
            "endOffset": 12583,
            "count": 0
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 2
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13612,
            "endOffset": 13643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 38
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 1
          },
          {
            "startOffset": 15268,
            "endOffset": 15326,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 38
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 11
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 5
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 5
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 6
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 1
          },
          {
            "startOffset": 16539,
            "endOffset": 16626,
            "count": 5
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 10
          },
          {
            "startOffset": 17341,
            "endOffset": 17348,
            "count": 1
          },
          {
            "startOffset": 17348,
            "endOffset": 17376,
            "count": 9
          },
          {
            "startOffset": 17376,
            "endOffset": 17409,
            "count": 7
          },
          {
            "startOffset": 17411,
            "endOffset": 17459,
            "count": 2
          },
          {
            "startOffset": 17459,
            "endOffset": 17564,
            "count": 9
          },
          {
            "startOffset": 17564,
            "endOffset": 18088,
            "count": 3
          },
          {
            "startOffset": 17675,
            "endOffset": 17797,
            "count": 2
          },
          {
            "startOffset": 17797,
            "endOffset": 18080,
            "count": 1
          },
          {
            "startOffset": 18088,
            "endOffset": 18174,
            "count": 9
          },
          {
            "startOffset": 18174,
            "endOffset": 18199,
            "count": 0
          },
          {
            "startOffset": 18199,
            "endOffset": 18227,
            "count": 9
          },
          {
            "startOffset": 18227,
            "endOffset": 18269,
            "count": 2
          },
          {
            "startOffset": 18269,
            "endOffset": 18319,
            "count": 7
          },
          {
            "startOffset": 18319,
            "endOffset": 18351,
            "count": 9
          },
          {
            "startOffset": 18351,
            "endOffset": 18412,
            "count": 0
          },
          {
            "startOffset": 18412,
            "endOffset": 18450,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17978,
            "endOffset": 18015,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 3
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 13
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 5
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 5
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 8
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 5
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 3
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 3
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 6
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 3
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 3
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 1
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 3
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 10
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 150
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 9
          },
          {
            "startOffset": 800,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 45
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 20
          },
          {
            "startOffset": 1446,
            "endOffset": 1453,
            "count": 11
          },
          {
            "startOffset": 1453,
            "endOffset": 1777,
            "count": 9
          },
          {
            "startOffset": 1724,
            "endOffset": 1729,
            "count": 0
          },
          {
            "startOffset": 1777,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 18
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 5
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 3
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 20
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 10
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 30
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 30
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 10
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 20
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 10
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 10
          },
          {
            "startOffset": 11819,
            "endOffset": 11969,
            "count": 20
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 10
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 11
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 20
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 10
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 10
          },
          {
            "startOffset": 16352,
            "endOffset": 16636,
            "count": 10
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 1
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 4
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 5
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 2
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 5
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 2
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 2
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 2
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 3
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 2
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 3
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 2
          },
          {
            "startOffset": 12425,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 3
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 2
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 1
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 1
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 1
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 2
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 7
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2830,
            "endOffset": 3673,
            "count": 2
          },
          {
            "startOffset": 2929,
            "endOffset": 2939,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2970,
            "endOffset": 3647,
            "count": 5
          },
          {
            "startOffset": 3365,
            "endOffset": 3381,
            "count": 2
          },
          {
            "startOffset": 3383,
            "endOffset": 3607,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3423,
            "endOffset": 3593,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3859,
            "endOffset": 3972,
            "count": 1
          },
          {
            "startOffset": 3938,
            "endOffset": 3949,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4130,
            "endOffset": 4213,
            "count": 2
          },
          {
            "startOffset": 4192,
            "endOffset": 4201,
            "count": 1
          },
          {
            "startOffset": 4202,
            "endOffset": 4206,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4458,
            "count": 1
          },
          {
            "startOffset": 4437,
            "endOffset": 4441,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 7
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 6
          },
          {
            "startOffset": 5274,
            "endOffset": 6323,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 6
          },
          {
            "startOffset": 4779,
            "endOffset": 4929,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5154,
            "endOffset": 5234,
            "count": 1
          },
          {
            "startOffset": 5219,
            "endOffset": 5223,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 3
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 1
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 1
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 1
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 7
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 14
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 7
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 7
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 7
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 7
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 4
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 60
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 6
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 6
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 13
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 7
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 6
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 6
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 7
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 3
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 4
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 3
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 4
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 3
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 4
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 3
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 6
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 6
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 5
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 4
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 4
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 4
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 4
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 1
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 3
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 0
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 0
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 0
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 0
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 3
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 6
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 3
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 3
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13612,
            "endOffset": 13643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 2
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 3
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 3
          },
          {
            "startOffset": 15268,
            "endOffset": 15326,
            "count": 1
          },
          {
            "startOffset": 15326,
            "endOffset": 15406,
            "count": 2
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 2
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 3
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 1
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 4
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 5
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 4
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 2
          },
          {
            "startOffset": 11271,
            "endOffset": 11732,
            "count": 1
          },
          {
            "startOffset": 11786,
            "endOffset": 11913,
            "count": 1
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 0
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 1
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 1
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 1
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 1
          },
          {
            "startOffset": 16352,
            "endOffset": 16636,
            "count": 1
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 2
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 7
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 0
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 0
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 0
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 0
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 4
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 2
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 1
          },
          {
            "startOffset": 800,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 2
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 3
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 2
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 1
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 3
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 1
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 1
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 2
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 1
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 1
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 2
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 1
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 2
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 6
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 5
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 2
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 8
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 4
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 0
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 0
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 1
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 1
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 1
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 3
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 2
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 1
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 1
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 1
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 1
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 3
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 3
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 0
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 0
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 13
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 5
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 5
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 8
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 5
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 3
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 3
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 6
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 3
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 3
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 0
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 0
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 1
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 3
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 6
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 3
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 3
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 0
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 3
          },
          {
            "startOffset": 792,
            "endOffset": 799,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 6
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 5
          },
          {
            "startOffset": 981,
            "endOffset": 1065,
            "count": 1
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 49
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2830,
            "endOffset": 3673,
            "count": 3
          },
          {
            "startOffset": 2929,
            "endOffset": 2939,
            "count": 1
          },
          {
            "startOffset": 2939,
            "endOffset": 3672,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 2970,
            "endOffset": 3647,
            "count": 3
          },
          {
            "startOffset": 3365,
            "endOffset": 3381,
            "count": 0
          },
          {
            "startOffset": 3383,
            "endOffset": 3607,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 3423,
            "endOffset": 3593,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 3859,
            "endOffset": 3972,
            "count": 2
          },
          {
            "startOffset": 3938,
            "endOffset": 3949,
            "count": 1
          },
          {
            "startOffset": 3950,
            "endOffset": 3963,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4130,
            "endOffset": 4213,
            "count": 4
          },
          {
            "startOffset": 4202,
            "endOffset": 4206,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4375,
            "endOffset": 4458,
            "count": 5
          },
          {
            "startOffset": 4437,
            "endOffset": 4441,
            "count": 4
          },
          {
            "startOffset": 4442,
            "endOffset": 4451,
            "count": 1
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 22
          },
          {
            "startOffset": 4658,
            "endOffset": 5274,
            "count": 15
          },
          {
            "startOffset": 5274,
            "endOffset": 6323,
            "count": 7
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 4715,
            "endOffset": 5267,
            "count": 15
          },
          {
            "startOffset": 4779,
            "endOffset": 4929,
            "count": 1
          },
          {
            "startOffset": 4929,
            "endOffset": 5266,
            "count": 14
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5154,
            "endOffset": 5234,
            "count": 4
          },
          {
            "startOffset": 5207,
            "endOffset": 5218,
            "count": 1
          },
          {
            "startOffset": 5219,
            "endOffset": 5223,
            "count": 3
          }
        ]
      },
      {
        "functionName": "innerHTML.split.reduce.markup",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5409,
            "endOffset": 5619,
            "count": 21
          },
          {
            "startOffset": 5455,
            "endOffset": 5480,
            "count": 7
          },
          {
            "startOffset": 5482,
            "endOffset": 5538,
            "count": 7
          },
          {
            "startOffset": 5538,
            "endOffset": 5589,
            "count": 14
          }
        ]
      },
      {
        "functionName": "fragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5728,
            "endOffset": 5955,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5848,
            "endOffset": 5866,
            "count": 8
          }
        ]
      },
      {
        "functionName": "template",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 5968,
            "endOffset": 6319,
            "count": 9
          },
          {
            "startOffset": 6030,
            "endOffset": 6242,
            "count": 1
          },
          {
            "startOffset": 6242,
            "endOffset": 6318,
            "count": 8
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 7
          },
          {
            "startOffset": 6414,
            "endOffset": 6429,
            "count": 2
          },
          {
            "startOffset": 6431,
            "endOffset": 6457,
            "count": 2
          },
          {
            "startOffset": 6457,
            "endOffset": 6497,
            "count": 5
          },
          {
            "startOffset": 6497,
            "endOffset": 6538,
            "count": 1
          },
          {
            "startOffset": 6538,
            "endOffset": 6631,
            "count": 4
          },
          {
            "startOffset": 6631,
            "endOffset": 6657,
            "count": 1
          },
          {
            "startOffset": 6657,
            "endOffset": 6722,
            "count": 3
          },
          {
            "startOffset": 6695,
            "endOffset": 6722,
            "count": 1
          },
          {
            "startOffset": 6722,
            "endOffset": 6816,
            "count": 2
          },
          {
            "startOffset": 6816,
            "endOffset": 6851,
            "count": 0
          },
          {
            "startOffset": 6853,
            "endOffset": 6925,
            "count": 2
          },
          {
            "startOffset": 6889,
            "endOffset": 6924,
            "count": 0
          },
          {
            "startOffset": 6932,
            "endOffset": 6971,
            "count": 0
          },
          {
            "startOffset": 6971,
            "endOffset": 6993,
            "count": 2
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 38
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 3
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 99
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 61
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 58
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 20
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 19
          },
          {
            "startOffset": 10296,
            "endOffset": 10359,
            "count": 1
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 21
          },
          {
            "startOffset": 7943,
            "endOffset": 7957,
            "count": 2
          },
          {
            "startOffset": 7959,
            "endOffset": 7973,
            "count": 2
          },
          {
            "startOffset": 7973,
            "endOffset": 8047,
            "count": 19
          },
          {
            "startOffset": 8047,
            "endOffset": 10153,
            "count": 18
          },
          {
            "startOffset": 8104,
            "endOffset": 8611,
            "count": 13
          },
          {
            "startOffset": 8567,
            "endOffset": 8574,
            "count": 0
          },
          {
            "startOffset": 8611,
            "endOffset": 10139,
            "count": 5
          },
          {
            "startOffset": 8731,
            "endOffset": 8792,
            "count": 4
          },
          {
            "startOffset": 8809,
            "endOffset": 9845,
            "count": 4
          },
          {
            "startOffset": 9845,
            "endOffset": 10139,
            "count": 1
          },
          {
            "startOffset": 10153,
            "endOffset": 10216,
            "count": 16
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 8908,
            "endOffset": 9786,
            "count": 4
          },
          {
            "startOffset": 9007,
            "endOffset": 9034,
            "count": 1
          },
          {
            "startOffset": 9036,
            "endOffset": 9133,
            "count": 1
          },
          {
            "startOffset": 9333,
            "endOffset": 9525,
            "count": 1
          },
          {
            "startOffset": 9525,
            "endOffset": 9727,
            "count": 3
          },
          {
            "startOffset": 9628,
            "endOffset": 9635,
            "count": 1
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 1
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 50
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 24
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 1
          },
          {
            "startOffset": 12682,
            "endOffset": 12735,
            "count": 49
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 63
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 62
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 47
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 1
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 0
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 0
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 0
          },
          {
            "startOffset": 12277,
            "endOffset": 12583,
            "count": 0
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 2
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 1
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 50
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 7
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13612,
            "endOffset": 13643,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 1
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 38
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 8
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14869,
            "endOffset": 14902,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15066,
            "endOffset": 15122,
            "count": 7
          }
        ]
      },
      {
        "functionName": "set",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15137,
            "endOffset": 15428,
            "count": 1
          },
          {
            "startOffset": 15268,
            "endOffset": 15326,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 38
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15670,
            "endOffset": 15701,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 38
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 11
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 5
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 5
          },
          {
            "startOffset": 16143,
            "endOffset": 16636,
            "count": 6
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 0
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 0
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 0
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 1
          },
          {
            "startOffset": 16539,
            "endOffset": 16626,
            "count": 5
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 10
          },
          {
            "startOffset": 17341,
            "endOffset": 17348,
            "count": 1
          },
          {
            "startOffset": 17348,
            "endOffset": 17376,
            "count": 9
          },
          {
            "startOffset": 17376,
            "endOffset": 17409,
            "count": 7
          },
          {
            "startOffset": 17411,
            "endOffset": 17459,
            "count": 2
          },
          {
            "startOffset": 17459,
            "endOffset": 17564,
            "count": 9
          },
          {
            "startOffset": 17564,
            "endOffset": 18088,
            "count": 3
          },
          {
            "startOffset": 17675,
            "endOffset": 17797,
            "count": 2
          },
          {
            "startOffset": 17797,
            "endOffset": 18080,
            "count": 1
          },
          {
            "startOffset": 18088,
            "endOffset": 18174,
            "count": 9
          },
          {
            "startOffset": 18174,
            "endOffset": 18199,
            "count": 0
          },
          {
            "startOffset": 18199,
            "endOffset": 18227,
            "count": 9
          },
          {
            "startOffset": 18227,
            "endOffset": 18269,
            "count": 2
          },
          {
            "startOffset": 18269,
            "endOffset": 18319,
            "count": 7
          },
          {
            "startOffset": 18319,
            "endOffset": 18351,
            "count": 9
          },
          {
            "startOffset": 18351,
            "endOffset": 18412,
            "count": 0
          },
          {
            "startOffset": 18412,
            "endOffset": 18450,
            "count": 9
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17978,
            "endOffset": 18015,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 1
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 10
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 150
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 9
          },
          {
            "startOffset": 800,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "storeFn",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 802,
            "endOffset": 813,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render2",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 869,
            "endOffset": 1071,
            "count": 45
          },
          {
            "startOffset": 915,
            "endOffset": 981,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 20
          },
          {
            "startOffset": 1446,
            "endOffset": 1453,
            "count": 11
          },
          {
            "startOffset": 1453,
            "endOffset": 1777,
            "count": 9
          },
          {
            "startOffset": 1724,
            "endOffset": 1729,
            "count": 0
          },
          {
            "startOffset": 1777,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 18
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 2
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 5
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 3
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 20
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 10
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 30
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 10
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 30
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 10
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 20
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 10
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 10
          },
          {
            "startOffset": 11819,
            "endOffset": 11969,
            "count": 20
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 10
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 0
          },
          {
            "startOffset": 12576,
            "endOffset": 12583,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 20
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 2
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 11
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 20
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 10
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 10
          },
          {
            "startOffset": 16352,
            "endOffset": 16636,
            "count": 10
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  },
  {
    "url": "http://localhost:5555/source/hyperElement.js",
    "scriptId": "6",
    "source": "// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  class hyperElement extends HTMLElement {\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n",
    "functions": [
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 0,
            "endOffset": 18941,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 143,
            "endOffset": 216,
            "count": 1
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 218,
            "endOffset": 18938,
            "count": 1
          }
        ]
      },
      {
        "functionName": "makeid",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 321,
            "endOffset": 535,
            "count": 1
          },
          {
            "startOffset": 444,
            "endOffset": 513,
            "count": 15
          }
        ]
      },
      {
        "functionName": "onNext",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 714,
            "endOffset": 1124,
            "count": 0
          }
        ]
      },
      {
        "functionName": "observer",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1303,
            "endOffset": 2553,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 1405,
            "endOffset": 2161,
            "count": 4
          },
          {
            "startOffset": 1453,
            "endOffset": 2160,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 1537,
            "endOffset": 1567,
            "count": 0
          }
        ]
      },
      {
        "functionName": "processAdvancedTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 2609,
            "endOffset": 4484,
            "count": 0
          }
        ]
      },
      {
        "functionName": "buildTemplate",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 4488,
            "endOffset": 6324,
            "count": 0
          }
        ]
      },
      {
        "functionName": "parceAttribute",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 6349,
            "endOffset": 6994,
            "count": 0
          }
        ]
      },
      {
        "functionName": "createdCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7195,
            "endOffset": 13835,
            "count": 4
          },
          {
            "startOffset": 13735,
            "endOffset": 13811,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7646,
            "endOffset": 7732,
            "count": 9
          },
          {
            "startOffset": 7691,
            "endOffset": 7710,
            "count": 5
          },
          {
            "startOffset": 7711,
            "endOffset": 7731,
            "count": 5
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 7756,
            "endOffset": 10394,
            "count": 1
          },
          {
            "startOffset": 7801,
            "endOffset": 10296,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wrapFragment",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 7894,
            "endOffset": 10217,
            "count": 0
          }
        ]
      },
      {
        "functionName": "toString",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 10401,
            "endOffset": 10477,
            "count": 0
          }
        ]
      },
      {
        "functionName": "Html",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10837,
            "endOffset": 12736,
            "count": 4
          },
          {
            "startOffset": 11059,
            "endOffset": 11110,
            "count": 2
          },
          {
            "startOffset": 11119,
            "endOffset": 12682,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 10935,
            "endOffset": 11046,
            "count": 3
          },
          {
            "startOffset": 10986,
            "endOffset": 11046,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11083,
            "endOffset": 11109,
            "count": 2
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 11206,
            "endOffset": 12657,
            "count": 5
          },
          {
            "startOffset": 11271,
            "endOffset": 11588,
            "count": 2
          },
          {
            "startOffset": 11588,
            "endOffset": 11732,
            "count": 3
          },
          {
            "startOffset": 11658,
            "endOffset": 11732,
            "count": 2
          },
          {
            "startOffset": 11786,
            "endOffset": 11819,
            "count": 2
          },
          {
            "startOffset": 11819,
            "endOffset": 11913,
            "count": 3
          },
          {
            "startOffset": 11913,
            "endOffset": 11969,
            "count": 2
          },
          {
            "startOffset": 11982,
            "endOffset": 12610,
            "count": 3
          },
          {
            "startOffset": 12100,
            "endOffset": 12277,
            "count": 0
          },
          {
            "startOffset": 12388,
            "endOffset": 12425,
            "count": 2
          },
          {
            "startOffset": 12425,
            "endOffset": 12583,
            "count": 1
          },
          {
            "startOffset": 12584,
            "endOffset": 12591,
            "count": 0
          }
        ]
      },
      {
        "functionName": "wire",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12774,
            "endOffset": 12842,
            "count": 0
          }
        ]
      },
      {
        "functionName": "lite",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 12864,
            "endOffset": 12927,
            "count": 0
          }
        ]
      },
      {
        "functionName": "render",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13156,
            "endOffset": 13712,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 13215,
            "endOffset": 13258,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13423,
            "endOffset": 13450,
            "count": 0
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 13469,
            "endOffset": 13704,
            "count": 0
          }
        ]
      },
      {
        "functionName": "get innerShadow",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14178,
            "endOffset": 14259,
            "count": 0
          }
        ]
      },
      {
        "functionName": "connectedCallback",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 14597,
            "endOffset": 14658,
            "count": 4
          }
        ]
      },
      {
        "functionName": "addDataset",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 14783,
            "endOffset": 15478,
            "count": 0
          }
        ]
      },
      {
        "functionName": "getDataset",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15502,
            "endOffset": 15764,
            "count": 4
          }
        ]
      },
      {
        "functionName": "",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 15583,
            "endOffset": 15712,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attachAttrs",
        "isBlockCoverage": true,
        "ranges": [
          {
            "startOffset": 15788,
            "endOffset": 16676,
            "count": 4
          },
          {
            "startOffset": 15895,
            "endOffset": 16644,
            "count": 3
          },
          {
            "startOffset": 15977,
            "endOffset": 15986,
            "count": 0
          },
          {
            "startOffset": 15988,
            "endOffset": 16143,
            "count": 0
          },
          {
            "startOffset": 16194,
            "endOffset": 16225,
            "count": 2
          },
          {
            "startOffset": 16227,
            "endOffset": 16270,
            "count": 1
          },
          {
            "startOffset": 16271,
            "endOffset": 16341,
            "count": 1
          },
          {
            "startOffset": 16352,
            "endOffset": 16427,
            "count": 1
          },
          {
            "startOffset": 16427,
            "endOffset": 16636,
            "count": 2
          },
          {
            "startOffset": 16486,
            "endOffset": 16539,
            "count": 0
          }
        ]
      },
      {
        "functionName": "attributeChangedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 17069,
            "endOffset": 18468,
            "count": 0
          }
        ]
      },
      {
        "functionName": "disconnectedCallback",
        "isBlockCoverage": false,
        "ranges": [
          {
            "startOffset": 18506,
            "endOffset": 18705,
            "count": 0
          }
        ]
      }
    ]
  }
]