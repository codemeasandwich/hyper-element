{
  "version": 3,
  "sources": ["../source/hyperElement.js"],
  "sourcesContent": ["// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n\n  // core/constants.js\n  /**\n   * @file Constants and regex patterns for hyper-element.\n   * Contains shared constants used throughout the library.\n   */\n\n  /**\n   * Regular expression to detect custom element tags in template strings.\n   * Matches patterns like `<my-element` or `<custom-component`.\n   * @type {RegExp}\n   */\n  const isCustomTag = /<+\\w+[-]+\\w/;\n\n  // core/manager.js\n  /**\n   * @file Global state management for hyper-element instances.\n   * Manages element instances and shared attributes between parent/child elements.\n   */\n\n  /**\n   * Reference object storing state for each element instance.\n   * @typedef {Object} ManagerRef\n   * @property {Object<string, boolean>} attrsToIgnore - Attributes to skip in change callback\n   * @property {string} innerHTML - Original innerHTML of the element\n   * @property {Object} this - The element context object\n   * @property {HTMLElement} shadow - The shadow/element root for rendering\n   * @property {Function} Html - The bound Html template function\n   * @property {boolean} observe - Whether MutationObserver should process changes\n   * @property {Function} [teardown] - Optional teardown function from setup\n   */\n\n  /**\n   * Map of element identifiers to their manager references.\n   * Uses Symbol keys for unique element identification.\n   * @type {Object<symbol, ManagerRef>}\n   */\n  const manager = {};\n\n  /**\n   * Shared attributes storage for passing functions/objects to child custom elements.\n   * Keys are random IDs, values contain the attribute name, value, and target localName.\n   * @type {Object<string, {attrName: string, val: any, localName: string}>}\n   */\n  const sharedAttrs = {};\n\n  // utils/makeid.js\n  /**\n   * @file Random ID generator utility.\n   * Generates unique identifiers for shared attribute references.\n   */\n\n  /**\n   * Generates a random 15-character ID using consonants only.\n   * Used to create unique keys for shared attributes between parent/child elements.\n   * @returns {string} A 15-character random string\n   * @example\n   * const id = makeid(); // e.g., \"bcdfghjklmnpqrs\"\n   */\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  // attributes/parseAttribute.js\n  /**\n   * @file Attribute parser with automatic type coercion.\n   * Converts string attribute values to appropriate JavaScript types.\n   */\n\n  /**\n   * Parses an attribute value and coerces it to the appropriate type.\n   * Handles numbers, booleans, JSON arrays/objects, and the special 'template' attribute.\n   *\n   * @param {string} key - The attribute name\n   * @param {string} value - The attribute value as a string\n   * @returns {string|number|boolean|Object|Array} The parsed/coerced value\n   * @example\n   * parseAttribute('count', '42');        // Returns 42 (number)\n   * parseAttribute('enabled', 'true');    // Returns true (boolean)\n   * parseAttribute('data', '[1,2,3]');    // Returns [1, 2, 3] (array)\n   * parseAttribute('template', '');       // Returns true (special case)\n   */\n  function parseAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    }\n\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  }\n\n  // template/processAdvancedTemplate.js\n  /**\n   * @file Advanced template processing with Handlebars-like syntax.\n   * Processes {#each}, {#if}, {#unless} constructs in templates.\n   */\n\n  /**\n   * Processes Handlebars-like constructs in template strings.\n   * Supports {#each array}...{/each}, {#if condition}...{else}...{/if},\n   * and {#unless condition}...{/unless} syntax.\n   *\n   * @param {string} template - The template string with advanced constructs\n   * @param {Object} data - Data object for template interpolation\n   * @returns {string} Processed template string with constructs resolved\n   * @example\n   * processAdvancedTemplate(\n   *   '{#each items}{.}{/each}',\n   *   { items: ['a', 'b', 'c'] }\n   * ); // Returns 'abc'\n   */\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  // template/buildTemplate.js\n  /**\n   * @file Template compiler for hyper-element.\n   * Compiles innerHTML templates into reusable template functions.\n   */\n\n\n  /**\n   * Builds a template function from an innerHTML string.\n   * Supports both simple {var} interpolation and advanced Handlebars-like syntax.\n   *\n   * @param {string} innerHTML - The template string to compile\n   * @returns {Function} A template function that accepts data and returns rendered content\n   * @throws {Error} If template function is called with non-object data\n   * @example\n   * const template = buildTemplate('<div>{name}</div>');\n   * template({ name: 'World' }); // Returns hyperHTML wire result\n   */\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    /**\n     * Creates the template output array for hyperHTML.wire.\n     * @param {Object} data - Data object for interpolation\n     * @returns {Array} Tagged template array with raw property\n     */\n    function fragment(data) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  }\n\n  // attributes/dataset.js\n  /**\n   * @file Dataset proxy utilities with automatic type coercion.\n   * Provides a proxied dataset with automatic type conversion on get/set.\n   */\n\n\n\n  /**\n   * Adds a property to the dataset proxy with automatic type coercion.\n   * The property getter parses the value, and the setter handles JSON serialization.\n   *\n   * @this {HTMLElement} The custom element instance\n   * @param {Object} dataset - The proxied dataset object\n   * @param {string} dash_key - The kebab-case attribute key (e.g., 'my-value')\n   * @returns {void}\n   */\n  function addDataset(dataset, dash_key) {\n    const camel_key = dash_key.replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n\n    Object.defineProperty(dataset, camel_key, {\n      enumerable: true, // can be selected\n      configurable: true, // can be delete\n      get: () => parseAttribute(camel_key, this.dataset[camel_key]),\n      set: (value) => {\n        manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n        if ('string' === typeof value) {\n          this.dataset[camel_key] = value;\n        } else {\n          this.dataset[camel_key] = JSON.stringify(value);\n        }\n      },\n    });\n  }\n\n  /**\n   * Creates a proxied dataset object from the element's dataset.\n   * Each property is converted from kebab-case to camelCase with type coercion.\n   *\n   * @this {HTMLElement} The custom element instance\n   * @returns {Object} Proxied dataset with automatic type coercion\n   */\n  function getDataset() {\n    const dataset = {};\n    Object.keys(this.dataset).forEach((key) =>\n      addDataset.call(\n        this,\n        dataset,\n        key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n      )\n    );\n    return dataset;\n  }\n\n  // attributes/attachAttrs.js\n  /**\n   * @file Attribute attachment logic for hyper-element.\n   * Attaches and processes element attributes including shared attributes.\n   */\n\n\n\n  /**\n   * Attaches attributes from the element to the context object.\n   * Handles template attributes, shared function/object attributes, and numeric coercion.\n   *\n   * @this {HTMLElement} The custom element instance\n   * @param {NamedNodeMap} attributes - The element's attributes collection\n   * @returns {Object} Object containing all parsed attributes\n   */\n  function attachAttrs(attributes) {\n    const accumulator = {};\n\n    for (let i = 0; i < attributes.length; i++) {\n      const { value, name } = attributes[i];\n\n      if ('template' === name && !value) {\n        const ref = manager[this.identifier];\n        ref.Html.template = buildTemplate(ref.innerHTML);\n        accumulator[name] = true;\n      } else if (\n        ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n        !!sharedAttrs[value.substr(3)] &&\n        sharedAttrs[value.substr(3)].localName === this.localName\n      ) {\n        accumulator[name] = sharedAttrs[value.substr(3)].val;\n      } else {\n        if (+value + '' === (value + '').trim()) {\n          accumulator[name] = +value;\n        } else {\n          accumulator[name] = value;\n        }\n      }\n    }\n    return accumulator;\n  }\n\n  // html/createHtml.js\n  /**\n   * @file Html function factory for hyperHTML binding.\n   * Creates the Html tagged template function with shared attribute handling.\n   */\n\n\n\n\n  /**\n   * Tagged template literal function for rendering HTML content.\n   * @typedef {Object} HtmlFunction\n   * @property {Function} wire - Create wired template bound to an object\n   * @property {Function} lite - Create lightweight template\n   * @property {Function} [template] - Template function when template attribute is used\n   */\n\n  /**\n   * Creates the Html tagged template function for an element.\n   * Handles passing functions and objects to child custom elements via shared attributes.\n   *\n   * @param {HTMLElement} shadow - The element's shadow/content root\n   * @returns {HtmlFunction} The Html template function\n   */\n  function createHtml(shadow) {\n    const hyperHTMLbind = hyperHTML.bind(shadow);\n\n    /**\n     * Html tagged template function for rendering content.\n     * Intercepts function/object values passed to custom elements and stores them for retrieval.\n     *\n     * @param {...any} args - Tagged template arguments (strings array + values)\n     * @returns {any} Result of hyperHTML.bind\n     */\n    function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          }\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          }\n        });\n      }\n\n      return hyperHTMLbind(...args);\n    }\n\n    /**\n     * Creates a wired template bound to an object.\n     * @param {...any} args - Arguments to pass to hyperHTML.wire\n     * @returns {any} Result of hyperHTML.wire\n     */\n    Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n\n    /**\n     * Creates a lightweight template without object binding.\n     * @param {...any} args - Arguments to pass to hyperHTML\n     * @returns {any} Result of hyperHTML\n     */\n    Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    return Html;\n  }\n\n  // lifecycle/onNext.js\n  /**\n   * @file Reactive re-render factory for store-based updates.\n   * Creates a render function that automatically passes store state.\n   */\n\n  /**\n   * Callback for store updates in setup.\n   * @callback OnNextCallback\n   * @param {any|Function} store - Store value or getter function\n   * @returns {Function} Render function with store\n   */\n\n  /**\n   * Creates a render function that injects store state on each render.\n   * This is called from setup() to enable reactive updates when store changes.\n   *\n   * @this {HTMLElement} The custom element instance\n   * @param {Object} that - The element context\n   * @param {any|Function} store - Store value or getter function\n   * @returns {Function} Render function that includes store state\n   * @example\n   * // In setup method:\n   * setup(onNext) {\n   *   const store = { count: 0 };\n   *   const render = onNext(() => store);\n   *   // render() will now pass store as first argument\n   * }\n   */\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  // lifecycle/observer.js\n  /**\n   * @file MutationObserver setup for content and attribute changes.\n   * Observes DOM mutations and triggers re-renders when content changes.\n   */\n\n  /**\n   * Sets up a MutationObserver to watch for content and attribute changes.\n   * Re-renders the element when mutations are detected.\n   *\n   * @this {HTMLElement} The custom element instance (must have attachAttrs, render methods)\n   * @param {Object} ref - The manager reference for this element\n   * @returns {void}\n   */\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      // Reset the element\n      hyperHTML.bind(ref.shadow)``;\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // lifecycle/connectedCallback.js\n  /**\n   * @file Core initialization logic for hyper-element connectedCallback.\n   * Sets up the element instance, observers, and render pipeline.\n   */\n\n\n\n\n\n\n\n  /**\n   * Result object returned from fragment methods (methods starting with capital letter).\n   * @typedef {Object} FragmentResult\n   * @property {any} [any] - Rendered content\n   * @property {boolean} [once] - Render only once\n   * @property {string|Promise} [template] - Template string or promise\n   * @property {Object|Array} [values] - Template values\n   * @property {string} [text] - Text content\n   * @property {string} [html] - HTML content\n   * @property {any} [placeholder] - Placeholder content\n   */\n\n  /**\n   * Core initialization callback, called when element is connected to DOM.\n   * Sets up the element instance, observers, fragment definitions, and initial render.\n   *\n   * @this {HTMLElement} The custom element instance (must be a hyperElement subclass)\n   * @returns {void}\n   */\n  function createdCallback() {\n    // Create unique identifier for this instance\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          /**\n           * Wraps a fragment method to handle template processing and caching.\n           * @param {Object} data - Data passed to the fragment\n           * @returns {FragmentResult} The fragment result\n           */\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                });\n              } else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            }\n            return result;\n          };\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n\n    /**\n     * Custom toString for element context.\n     * @returns {string} String representation\n     */\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n\n    // Use shadow DOM, else fallback to render to element\n    ref.shadow = this;\n\n    // Create the Html function and attach to ref\n    ref.Html = createHtml(ref.shadow);\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      // After render check if dataset has changed\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          addDataset.call(\n            this,\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  // hyperElement.js\n  /**\n   * @file hyperElement base class definition.\n   * The main class that custom elements extend to use hyperHTML templating.\n   */\n\n\n\n\n\n  /**\n   * Context object available as `this` in render() and setup() methods.\n   * @typedef {Object} ElementContext\n   * @property {HTMLElement} element - The DOM element\n   * @property {Object} attrs - Parsed attributes from the element\n   * @property {Object} dataset - Dataset proxy with automatic type coercion\n   * @property {any} [store] - Store value from setup\n   * @property {string} wrappedContent - Text content of element\n   */\n\n  /**\n   * Base class for creating custom elements with hyperHTML templating.\n   * Extend this class and implement the render() method to create a custom element.\n   *\n   * @example\n   * class MyElement extends hyperElement {\n   *   render(Html) {\n   *     Html`<div>Hello ${this.attrs.name}</div>`;\n   *   }\n   * }\n   * customElements.define('my-element', MyElement);\n   *\n   * @extends HTMLElement\n   */\n  class hyperElement extends HTMLElement {\n    /**\n     * Unique identifier for this element instance.\n     * @type {symbol}\n     */\n    identifier;\n\n    /**\n     * Gets the innerHTML of the element's shadow/content root.\n     * @returns {string} The inner HTML content\n     */\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    /**\n     * Called when the element is inserted into a document.\n     * Initializes the element, sets up observers, and triggers initial render.\n     * @returns {void}\n     */\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    /**\n     * Adds a property to the dataset proxy with automatic type coercion.\n     * @param {Object} dataset - The proxied dataset object\n     * @param {string} dash_key - The kebab-case attribute key\n     * @returns {void}\n     */\n    addDataset(dataset, dash_key) {\n      addDataset.call(this, dataset, dash_key);\n    }\n\n    /**\n     * Creates a proxied dataset object from the element's dataset.\n     * @returns {Object} Proxied dataset with automatic type coercion\n     */\n    getDataset() {\n      return getDataset.call(this);\n    }\n\n    /**\n     * Attaches attributes from the element to the context object.\n     * @param {NamedNodeMap} attributes - The element's attributes collection\n     * @returns {Object} Object containing all parsed attributes\n     */\n    attachAttrs(attributes) {\n      return attachAttrs.call(this, attributes);\n    }\n\n    /**\n     * Called when an observed attribute changes.\n     * Updates the context and triggers re-render if needed.\n     *\n     * @param {string} name - The attribute name\n     * @param {string|null} oldVal - The previous value\n     * @param {string|null} newVal - The new value\n     * @returns {void}\n     */\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      }\n    }\n\n    /**\n     * Called when the element is removed from the document.\n     * Calls the teardown function if one was returned from setup().\n     * @returns {void}\n     */\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n    }\n\n    /**\n     * Optional setup lifecycle method. Called once when the element is connected.\n     * Use this to set up stores, subscriptions, or other initialization logic.\n     *\n     * @param {Function} onNext - Call this with a store value or getter to enable reactive updates\n     * @returns {void|Function} Optional teardown function called when element is disconnected\n     *\n     * @example\n     * setup(onNext) {\n     *   const store = createStore({ count: 0 });\n     *   onNext(store.getState);\n     *   return store.subscribe(() => this.render());\n     * }\n     */\n    setup(onNext) {} // eslint-disable-line no-unused-vars\n\n    /**\n     * Required render lifecycle method. Called on every render cycle.\n     * Use the Html template tag to render content to the element.\n     *\n     * @param {Object} Html - Tagged template literal function for rendering\n     * @param {...any} data - Additional data passed from store updates\n     * @returns {void}\n     *\n     * @example\n     * render(Html) {\n     *   Html`<div>Hello ${this.attrs.name}!</div>`;\n     * }\n     */\n    render(Html, ...data) {} // eslint-disable-line no-unused-vars\n  }\n\n  return hyperElement;\n});\n"],
  "mappings": "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",
  "names": ["factory", "hyperHTML", "isCustomTag", "manager", "sharedAttrs", "makeid", "text", "possible", "i", "parseAttribute", "key", "value", "lowerCaseValue", "processAdvancedTemplate", "template", "data", "result", "eachRegex", "match", "arrayName", "content", "arr", "item", "index", "itemContent", "ifElseRegex", "condition", "ifContent", "elseContent", "ifRegex", "unlessRegex", "buildTemplate", "innerHTML", "re", "templateVals", "vals", "fragment", "output", "addDataset", "dataset", "dash_key", "camel_key", "g", "getDataset", "attachAttrs", "attributes", "accumulator", "name", "ref", "createHtml", "shadow", "hyperHTMLbind", "Html", "args", "t", "inCustomTag", "localName", "_items", "val", "attrName", "id", "onNext", "that", "store", "storeFn", "render", "render2", "observer", "mutations", "m", "textContent", "createdCallback", "templatestrings", "wrapFragment", "values", "toString", "hyperElement", "oldVal", "newVal", "attrsToIgnore", "dataSetName"]
}
