{
  "version": 3,
  "sources": ["../source/hyperElement.js"],
  "sourcesContent": ["// Browser-only build - UMD wrapper simplified for E2E testing\n// CommonJS/AMD paths exist in full build but are not covered by browser tests\n(function (factory) {\n  window.hyperElement = factory(window.hyperHTML);\n})(function (hyperHTML) {\n  /**\n   * @typedef {Object} HtmlFunction\n   * @property {function(Object, string=): function(TemplateStringsArray, ...any): any} wire - Create wired template bound to an object\n   * @property {function(TemplateStringsArray, ...any): any} lite - Create lightweight template\n   * @property {function(Object): any} [template] - Template function when template attribute is used\n   */\n\n  /**\n   * @typedef {Object} ElementContext\n   * @property {HTMLElement} element - The DOM element\n   * @property {Record<string, any>} attrs - Parsed attributes from the element\n   * @property {Record<string, any>} dataset - Dataset proxy with automatic type coercion\n   * @property {any} [store] - Store value from setup\n   * @property {string} wrappedContent - Text content of element\n   */\n\n  /**\n   * @typedef {Object} FragmentResult\n   * @property {any} [any] - Rendered content\n   * @property {boolean} [once] - Render only once\n   * @property {string|Promise<string|{template:string, values:Object|any[]}>} [template] - Template string or promise\n   * @property {Object|any[]} [values] - Template values\n   * @property {string} [text] - Text content\n   * @property {string} [html] - HTML content\n   * @property {any} [placeholder] - Placeholder content\n   */\n\n  /**\n   * Callback for store updates in setup\n   * @callback OnNextCallback\n   * @param {any|function(): any} store - Store value or getter function\n   * @returns {function(...any): void} - Render function with store\n   */\n\n  const manager = {},\n    sharedAttrs = {},\n    isCustomTag = /<+\\w+[-]+\\w/;\n\n  function makeid() {\n    var text = '';\n    var possible = 'bcdfghjklmnpqrstvwxyz';\n\n    for (var i = 0; i < 15; i++)\n      text += possible.charAt(Math.floor(Math.random() * possible.length));\n\n    return text;\n  }\n\n  //=====================================================\n  //=========================== re-render on store change\n  //=====================================================\n\n  function onNext(that, store) {\n    const storeFn = 'function' == typeof store ? store : () => store;\n\n    const render = this.render;\n\n    const render2 = (...data) => {\n      if (undefined === store) {\n        that.store = undefined;\n        render(...data);\n      } else {\n        that.store = storeFn();\n        render(that.store, ...data);\n      }\n    };\n    this.render = render2;\n\n    return render2;\n  }\n\n  //=====================================================\n  //======================== Observer change to innerHTML\n  //=====================================================\n\n  function observer(ref) {\n    const that = ref.this;\n    const mutationObserver = new MutationObserver((mutations) => {\n      if (!ref.observe) return;\n\n      // Check for attribute changes\n      const attrMutations = mutations.filter((m) => m.type === 'attributes');\n      if (attrMutations.length > 0) {\n        // Re-attach attrs to pick up new shared attr values\n        that.attrs = this.attachAttrs(this.attributes) || {};\n        this.render();\n        return;\n      }\n\n      // Handle content changes\n      let textContent = this.textContent;\n\n      ref.innerHTML = this.innerHTML;\n      if (that.attrs.template) {\n        that.attrs = this.attachAttrs(this.attributes) || {};\n      }\n\n      //reset the element\n      hyperHTML.bind(ref.shadow)``; // HACK, dont know why this works?\n\n      that.wrappedContent = textContent;\n      this.render();\n    });\n\n    mutationObserver.observe(this, {\n      // Watch attribute changes to trigger re-renders\n      attributes: true,\n\n      // Set to true if additions and removals of the target node's child elements (including text nodes) are to be observed.\n      childList: true,\n\n      // Set to true if mutations to target and target's descendants are to be observed.\n      subtree: true,\n    });\n  }\n\n  // Process handlebars-like constructs in template\n  function processAdvancedTemplate(template, data) {\n    let result = template;\n\n    // Process {#each array}...{/each}\n    const eachRegex = /\\{#each\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/each\\}/g;\n    result = result.replace(eachRegex, (match, arrayName, content) => {\n      const arr = data[arrayName];\n      if (!Array.isArray(arr)) return '';\n      return arr\n        .map((item, index) => {\n          let itemContent = content;\n          // Replace {.} with current item (for primitives)\n          itemContent = itemContent.replace(/\\{\\.\\}/g, item);\n          // Replace {@index} with current index\n          itemContent = itemContent.replace(/\\{@index\\}/g, index);\n          // If item is object, replace {prop} with item.prop\n          if (typeof item === 'object' && item !== null) {\n            Object.keys(item).forEach((key) => {\n              itemContent = itemContent.replace(\n                new RegExp('\\\\{' + key + '\\\\}', 'g'),\n                item[key]\n              );\n            });\n          }\n          return itemContent;\n        })\n        .join('');\n    });\n\n    // Process {#if condition}...{else}...{/if}\n    const ifElseRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{else\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(\n      ifElseRegex,\n      (match, condition, ifContent, elseContent) => {\n        return data[condition] ? ifContent : elseContent;\n      }\n    );\n\n    // Process {#if condition}...{/if} (without else)\n    const ifRegex = /\\{#if\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/if\\}/g;\n    result = result.replace(ifRegex, (match, condition, content) => {\n      return data[condition] ? content : '';\n    });\n\n    // Process {#unless condition}...{/unless}\n    const unlessRegex = /\\{#unless\\s+(\\w+)\\}([\\s\\S]*?)\\{\\/unless\\}/g;\n    result = result.replace(unlessRegex, (match, condition, content) => {\n      return data[condition] ? '' : content;\n    });\n\n    return result;\n  }\n\n  function buildTemplate(innerHTML) {\n    // Check if template has advanced features\n    const hasAdvanced = /\\{#(if|each|unless)\\s/.test(innerHTML);\n\n    if (hasAdvanced) {\n      // Use advanced template processing\n      return function template(data) {\n        if ('object' !== typeof data) {\n          throw new Error(\n            'Templates must be passed an object. You passed ' +\n              JSON.stringify(data)\n          );\n        }\n        // Process advanced template features\n        let result = processAdvancedTemplate(innerHTML, data);\n        // Simple variable substitution for remaining {var} patterns\n        result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {\n          return data[key] != null ? data[key] : '';\n        });\n        return result;\n      };\n    }\n\n    // Original simple template processing\n    const re = /(\\{[\\w]+\\})/g;\n    const templateVals = innerHTML.split(re).reduce(\n      (vals, item) => {\n        if ('{' === item[0] && '}' === item.slice(-1)) {\n          vals.keys.push(item.slice(1, -1));\n        } else {\n          vals.markup.push(item);\n        }\n\n        return vals;\n      },\n      { markup: [], keys: [] }\n    );\n\n    templateVals.id = ':' + templateVals.markup.join().trim();\n\n    function fragment(data, _render) {\n      const output = [\n        templateVals.markup,\n        ...templateVals.keys.map((key) => data[key]),\n      ];\n      output.raw = { value: templateVals.markup };\n      return output;\n    }\n\n    return function template(data) {\n      if ('object' !== typeof data) {\n        throw new Error(\n          'Templates must be passed an object to be populated with. You passed ' +\n            JSON.stringify(data) +\n            ' to ' +\n            templateVals.id\n        );\n      }\n      return hyperHTML.wire(data, templateVals.id)(...fragment(data));\n    };\n  } // END buildTemplate\n\n  function parceAttribute(key, value) {\n    if ('template' === key && '' === value) {\n      return true;\n    }\n\n    if (+value + '' === value.trim()) {\n      return +value; // to number\n    }\n\n    const lowerCaseValue = value.toLowerCase().trim();\n\n    if ('true' === lowerCaseValue) {\n      return true;\n    } else if ('false' === lowerCaseValue) {\n      return false;\n    } // END boolean check\n\n    //if(\"data-json\"===key){\n    if (\n      (lowerCaseValue[0] === '[' && lowerCaseValue.slice(-1) === ']') ||\n      (lowerCaseValue[0] === '{' && lowerCaseValue.slice(-1) === '}')\n    ) {\n      return JSON.parse(value);\n    }\n\n    return value;\n  } // END parceAttribute\n\n  //=====================================================\n  //======================================= All the magic\n  //=====================================================\n\n  function createdCallback() {\n    // an instance of the element is created\n    this.identifier = Symbol(this.localName);\n    const ref = (manager[this.identifier] = { attrsToIgnore: {} });\n    ref.innerHTML = this.innerHTML;\n    const that = (ref.this = { element: this });\n    that.wrappedContent = this.textContent;\n\n    observer.call(this, ref); // observer change to innerHTML\n\n    Object.getOwnPropertyNames(this.__proto__)\n      .filter(\n        (name) =>\n          !('constructor' === name || 'setup' === name || 'render' === name)\n      )\n      .forEach((name) => {\n        if (/^[A-Z]/.test(name)) {\n          let result;\n          const templatestrings = {};\n          const wrapFragment = (data) => {\n            if (undefined !== result && result.once) return result;\n\n            result = this[name](data);\n            if (result.template) {\n              if ('string' === typeof result.template) {\n                /* if(undefined === result.values){\n                    throw new Error(\"'values' was not defined for a 'template' in \"+name)\n                  }*/\n                if (!templatestrings[result.template]) {\n                  templatestrings[result.template] = buildTemplate(\n                    result.template\n                  );\n                }\n                result = {\n                  any: templatestrings[result.template](result.values || data),\n                };\n              } // END \"string\" === typeof result.template\n              else if (\n                'object' === typeof result.template &&\n                'function' === typeof result.template.then\n              ) {\n                result = Object.assign({}, result, {\n                  any: result.template.then((args) => {\n                    let { template, values } = args;\n                    if (!template && 'string' === typeof args) {\n                      template = args;\n                      values = {};\n                    }\n\n                    if (!templatestrings[template]) {\n                      templatestrings[template] = buildTemplate(template);\n                    }\n                    if (Array.isArray(values)) {\n                      result = {\n                        any: values.map(templatestrings[template]),\n                        once: result.once,\n                      };\n                    } else {\n                      result = {\n                        any: templatestrings[template](values || data),\n                        once: result.once,\n                      };\n                    }\n                    return result.any;\n                  }),\n                }); // END Object.assign\n              } // END result.template is promise ?\n              else {\n                throw new Error(\n                  'unknow template type:' +\n                    typeof result.template +\n                    ' | ' +\n                    JSON.stringify(result.template)\n                );\n              }\n            } // END !!result.template\n            return result;\n          }; // END wrapFragment\n          hyperHTML.define(name, wrapFragment);\n        } else {\n          that[name] = this[name].bind(that);\n        }\n        delete this[name];\n      });\n    function toString() {\n      return 'hyper-element: ' + this.localName;\n    }\n    Object.defineProperty(that, 'toString', {\n      value: toString.bind(this),\n      writable: false,\n    });\n    // use shadow DOM, else fallback to render to element\n    ref.shadow = this; //.attachShadow ? this.attachShadow({mode: 'closed'}) : this\n\n    // Restrict access to hyperHTML\n    const hyperHTMLbind = hyperHTML.bind(ref.shadow);\n    ref.Html = function Html(...args) {\n      if (\n        args\n          .slice(1)\n          .some(\n            (item) =>\n              'function' === typeof item ||\n              (item !== null && 'object' === typeof item)\n          ) &&\n        args[0].some((t) => isCustomTag.test(t))\n      ) {\n        let inCustomTag = false;\n        let localName = '';\n        args[0].forEach((item, index, _items) => {\n          if (isCustomTag.test(item)) {\n            inCustomTag =\n              -1 === item.substring(item.match(isCustomTag).index).indexOf('>');\n            localName =\n              inCustomTag &&\n              item\n                .substring(item.indexOf(item.match(isCustomTag)))\n                .split(' ')[0]\n                .substr(1);\n          } // END if CustomTag start\n          else if (0 <= item.indexOf('>')) {\n            inCustomTag = false;\n            localName = '';\n          } // END if CustomTag end\n\n          if (!inCustomTag) {\n            return;\n          }\n          const val = args[index + 1];\n\n          if (\n            'function' === typeof val ||\n            (val !== null && 'object' === typeof val)\n          ) {\n            const attrName = item.split(' ').pop().slice(0, -1);\n            if ('on' === attrName.substring(0, 2)) {\n              throw new Error(\n                `'on' is reserve for native elements. Change: \"${attrName}\" for \"${localName}\" to something else`\n              );\n            }\n            // Don't intercept style - let hyperHTML handle it natively\n            if ('style' === attrName) {\n              return;\n            }\n            const id = makeid();\n            sharedAttrs[id] = { attrName, val, localName };\n            args[index + 1] = ('function' === typeof val ? 'fn-' : 'ob-') + id;\n          } // END if(\"function\" === typeof val)\n        }); // END forEach\n      } // END if\n\n      return hyperHTMLbind(...args);\n    }; // END ref.Html\n    ref.Html.wire = function wire(...args) {\n      return hyperHTML.wire(...args);\n    };\n    ref.Html.lite = function lite(...args) {\n      return hyperHTML(...args);\n    };\n\n    // Guard removed: this.attrs is set by the library, cannot be pre-defined by user\n    that.attrs = this.attachAttrs(this.attributes);\n    that.dataset = this.getDataset();\n    const render = this.render;\n    this.render = (...data) => {\n      ref.observe = false;\n      setTimeout(() => {\n        ref.observe = true;\n      }, 0);\n\n      render.call(that, ref.Html, ...data);\n\n      //after render check if dataset has chacked\n      Object.getOwnPropertyNames(that.dataset)\n        .filter((key) => !this.dataset[key])\n        .forEach((key) => {\n          const value = that.dataset[key];\n          this.addDataset(\n            that.dataset,\n            key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n          );\n          that.dataset[key] = value;\n        });\n    };\n\n    if (this.setup) {\n      ref.teardown = this.setup.call(that, onNext.bind(this, that));\n    }\n\n    this.render();\n  }\n\n  //=====================================================\n  //==================================== Wrap the element\n  //=====================================================\n\n  /**\n   * Base class for creating custom elements with hyperHTML templating.\n   * Extend this class and implement the render() method to create a custom element.\n   *\n   * @example\n   * class MyElement extends hyperElement {\n   *   render(Html) {\n   *     Html`<div>Hello ${this.attrs.name}</div>`;\n   *   }\n   * }\n   * customElements.define('my-element', MyElement);\n   *\n   * @extends HTMLElement\n   */\n  class hyperElement extends HTMLElement {\n    /**\n     * Unique identifier for this element instance\n     * @type {symbol}\n     */\n    identifier;\n    //++++++++++++++++++++++++++++++++ get element content\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    get innerShadow() {\n      return manager[this.identifier].shadow.innerHTML;\n    }\n\n    //++++++++++++++++++++++++++++++++++++++++++++++ Setup\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    // createdCallback is the deprecated v0 Custom Elements API\n    // Modern browsers only call connectedCallback (v1 API)\n\n    // Called when the element is inserted into a document, including into a shadow tree\n    connectedCallback() {\n      createdCallback.call(this);\n    }\n\n    //+++++++++++++++++++++++++++++++++++++++ attach Attrs\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    addDataset(dataset, dash_key) {\n      const camel_key = dash_key.replace(/-([a-z])/g, (g) =>\n        g[1].toUpperCase()\n      );\n\n      Object.defineProperty(dataset, camel_key, {\n        enumerable: true, // can be selected\n        configurable: true, // can be delete\n        get: () => parceAttribute(camel_key, this.dataset[camel_key]),\n        set: (value) => {\n          manager[this.identifier].attrsToIgnore['data-' + dash_key] = true;\n          if ('string' === typeof value) {\n            this.dataset[camel_key] = value;\n          } else {\n            this.dataset[camel_key] = JSON.stringify(value);\n          } // END else\n        }, // END set\n      }); // END defineProperty\n    } // END addDataset\n\n    getDataset() {\n      const dataset = {};\n      Object.keys(this.dataset).forEach((key) =>\n        this.addDataset(\n          dataset,\n          key.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`)\n        )\n      ); // END forEach\n      return dataset;\n    } // END getDataset\n\n    attachAttrs(attributes) {\n      const accumulator = {};\n\n      for (let i = 0; i < attributes.length; i++) {\n        const { value, name } = attributes[i];\n\n        if ('template' === name && !value) {\n          const ref = manager[this.identifier];\n          ref.Html.template = buildTemplate(ref.innerHTML);\n          accumulator[name] = true;\n        } else if (\n          ('fn-' === value.substr(0, 3) || 'ob-' === value.substr(0, 3)) &&\n          !!sharedAttrs[value.substr(3)] &&\n          sharedAttrs[value.substr(3)].localName === this.localName\n        ) {\n          accumulator[name] = sharedAttrs[value.substr(3)].val;\n        } else {\n          if (+value + '' === (value + '').trim()) {\n            accumulator[name] = +value;\n          } else {\n            accumulator[name] = value; //parceAttribute(name,value)\n          }\n        }\n      }\n      return accumulator;\n    }\n    /*\n    attachedCallback(){\n    \tconsole.log(\"an instance was inserted into the document\")\n        //an instance was inserted into the document\n    }\n*/\n\n    //+++++++++++++++++++++++++++++++++++ element teardown\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++\n    /*\n    detachedCallback(){\n      this.disposer && this.disposer()\n      this.disconnectedCallback()\n    }\n*/\n    attributeChangedCallback(name, oldVal, newVal) {\n      // Guard: attributeChangedCallback can fire before connectedCallback\n      // when observedAttributes is defined and attributes are set before DOM insertion\n      const ref = manager[this.identifier];\n      if (!ref) return;\n\n      if (newVal !== null && +newVal + '' === newVal.trim()) {\n        newVal = +newVal; // to number\n      }\n      const { attrsToIgnore } = ref;\n      const that = ref.this;\n      if (0 <= name.indexOf('data-')) {\n        // we have data\n        const dataSetName = name.slice('data-'.length);\n        if (null === oldVal) {\n          //if(undefined === that.dataset[dataSetName]){\n          this.addDataset(that.dataset, dataSetName);\n        } else if (null === newVal) {\n          //  Object.defineProperty(that.dataset, dataSetName, {  }) // END defineProperty\n          const camel_key = dataSetName.replace(/-([a-z])/g, (g) =>\n            g[1].toUpperCase()\n          );\n          delete that.dataset[camel_key];\n        }\n      }\n      //newVal = parceAttribute(name,newVal)\n\n      if (newVal === that.attrs[name]) {\n        return;\n      }\n      if (null === newVal) {\n        delete that.attrs[name];\n      } else {\n        that.attrs[name] = newVal;\n      }\n      if (attrsToIgnore[name]) {\n        delete attrsToIgnore[name];\n        return;\n      } else {\n        this.render();\n      } // END else\n    } // END attributeChangedCallback\n\n    disconnectedCallback() {\n      const ref = manager[this.identifier];\n      ref.teardown && ref.teardown();\n      //ref.teardown = null\n      //Called when the element is removed from a document\n    } // END disconnectedCallback\n\n    /**\n     * Optional setup lifecycle method. Called once when the element is connected.\n     * Use this to set up stores, subscriptions, or other initialization logic.\n     *\n     * @param {OnNextCallback} onNext - Call this with a store value or getter to enable reactive updates\n     * @returns {void|function(): void} Optional teardown function called when element is disconnected\n     *\n     * @example\n     * setup(onNext) {\n     *   const store = createStore({ count: 0 });\n     *   onNext(store.getState);\n     *   return store.subscribe(() => this.render());\n     * }\n     */\n    setup(onNext) {} // eslint-disable-line no-unused-vars\n\n    /**\n     * Required render lifecycle method. Called on every render cycle.\n     * Use the Html template tag to render content to the element.\n     *\n     * @param {HtmlFunction} Html - Tagged template literal function for rendering\n     * @param {...any} data - Additional data passed from store updates\n     * @returns {void}\n     *\n     * @example\n     * render(Html) {\n     *   Html`<div>Hello ${this.attrs.name}!</div>`;\n     * }\n     */\n    render(Html, ...data) {} // eslint-disable-line no-unused-vars\n  }\n\n  //=====================================================\n  //================================================ Done\n  //=====================================================\n\n  return hyperElement;\n});\n"],
  "mappings": "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",
  "names": ["factory", "hyperHTML", "manager", "sharedAttrs", "isCustomTag", "makeid", "text", "possible", "i", "onNext", "that", "store", "storeFn", "render", "render2", "data", "observer", "ref", "mutations", "m", "textContent", "processAdvancedTemplate", "template", "result", "eachRegex", "match", "arrayName", "content", "arr", "item", "index", "itemContent", "key", "ifElseRegex", "condition", "ifContent", "elseContent", "ifRegex", "unlessRegex", "buildTemplate", "innerHTML", "re", "templateVals", "vals", "fragment", "_render", "output", "parceAttribute", "value", "lowerCaseValue", "createdCallback", "name", "templatestrings", "wrapFragment", "args", "values", "toString", "hyperHTMLbind", "t", "inCustomTag", "localName", "_items", "val", "attrName", "id", "g", "hyperElement", "dataset", "dash_key", "camel_key", "attributes", "accumulator", "oldVal", "newVal", "attrsToIgnore", "dataSetName", "Html"]
}
